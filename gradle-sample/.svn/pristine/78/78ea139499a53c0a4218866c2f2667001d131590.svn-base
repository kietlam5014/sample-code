
/**
 * almond 0.2.0 Copyright (c) 2011, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        aps = [].slice;

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap,
            foundI, foundStarMap, starI, i, j, part,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                //Convert baseName to array, and lop off the last part,
                //so that . matches that "directory" and not name of the baseName's
                //module. For instance, baseName of "one/two/three", maps to
                //"one/two/three.js", but we want the directory, "one/two" for
                //this normalization.
                baseParts = baseParts.slice(0, baseParts.length - 1);

                name = baseParts.concat(name.split("/"));

                //start trimDots
                for (i = 0; i < name.length; i += 1) {
                    part = name[i];
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (waiting.hasOwnProperty(name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!defined.hasOwnProperty(name) && !defining.hasOwnProperty(name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relName) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i,
            args = [],
            usingExports;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (typeof callback === 'function') {

            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (defined.hasOwnProperty(depName) ||
                           waiting.hasOwnProperty(depName) ||
                           defining.hasOwnProperty(depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback.apply(defined[name], args);

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 15);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        config = cfg;
        return req;
    };

    define = function (name, deps, callback) {

    	// TODO: remove the following block once the metrics issue is mitigated
    	if (typeof name === 'function' && !deps) {
    		return;
    	}
    	
        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        waiting[name] = [name, deps, callback];
    };

    define.amd = {
        jQuery: true
    };
}());

/* Zepto v1.0rc1 - polyfill zepto event detect fx ajax form touch - zeptojs.com/license */
(function(a){String.prototype.trim===a&&(String.prototype.trim=function(){return this.replace(/^\s+/,"").replace(/\s+$/,"")}),Array.prototype.reduce===a&&(Array.prototype.reduce=function(b){if(this===void 0||this===null)throw new TypeError;var c=Object(this),d=c.length>>>0,e=0,f;if(typeof b!="function")throw new TypeError;if(d==0&&arguments.length==1)throw new TypeError;if(arguments.length>=2)f=arguments[1];else do{if(e in c){f=c[e++];break}if(++e>=d)throw new TypeError}while(!0);while(e<d)e in c&&(f=b.call(a,f,c[e],e,c)),e++;return f})})();var Zepto=function(){function A(a){return v.call(a)=="[object Function]"}function B(a){return a instanceof Object}function C(b){var c,d;if(v.call(b)!=="[object Object]")return!1;d=A(b.constructor)&&b.constructor.prototype;if(!d||!hasOwnProperty.call(d,"isPrototypeOf"))return!1;for(c in b);return c===a||hasOwnProperty.call(b,c)}function D(a){return a instanceof Array}function E(a){return typeof a.length=="number"}function F(b){return b.filter(function(b){return b!==a&&b!==null})}function G(a){return a.length>0?[].concat.apply([],a):a}function H(a){return a.replace(/::/g,"/").replace(/([A-Z]+)([A-Z][a-z])/g,"$1_$2").replace(/([a-z\d])([A-Z])/g,"$1_$2").replace(/_/g,"-").toLowerCase()}function I(a){return a in i?i[a]:i[a]=new RegExp("(^|\\s)"+a+"(\\s|$)")}function J(a,b){return typeof b=="number"&&!k[H(a)]?b+"px":b}function K(a){var b,c;return h[a]||(b=g.createElement(a),g.body.appendChild(b),c=j(b,"").getPropertyValue("display"),b.parentNode.removeChild(b),c=="none"&&(c="block"),h[a]=c),h[a]}function L(b,d){return d===a?c(b):c(b).filter(d)}function M(a,b,c,d){return A(b)?b.call(a,c,d):b}function N(a,b,d){var e=a%2?b:b.parentNode;e?e.insertBefore(d,a?a==1?e.firstChild:a==2?b:null:b.nextSibling):c(d).remove()}function O(a,b){b(a);for(var c in a.childNodes)O(a.childNodes[c],b)}var a,b,c,d,e=[],f=e.slice,g=window.document,h={},i={},j=g.defaultView.getComputedStyle,k={"column-count":1,columns:1,"font-weight":1,"line-height":1,opacity:1,"z-index":1,zoom:1},l=/^\s*<(\w+|!)[^>]*>/,m=[1,3,8,9,11],n=["after","prepend","before","append"],o=g.createElement("table"),p=g.createElement("tr"),q={tr:g.createElement("tbody"),tbody:o,thead:o,tfoot:o,td:p,th:p,"*":g.createElement("div")},r=/complete|loaded|interactive/,s=/^\.([\w-]+)$/,t=/^#([\w-]+)$/,u=/^[\w-]+$/,v={}.toString,w={},x,y,z=g.createElement("div");return w.matches=function(a,b){if(!a||a.nodeType!==1)return!1;var c=a.webkitMatchesSelector||a.mozMatchesSelector||a.oMatchesSelector||a.matchesSelector;if(c)return c.call(a,b);var d,e=a.parentNode,f=!e;return f&&(e=z).appendChild(a),d=~w.qsa(e,b).indexOf(a),f&&z.removeChild(a),d},x=function(a){return a.replace(/-+(.)?/g,function(a,b){return b?b.toUpperCase():""})},y=function(a){return a.filter(function(b,c){return a.indexOf(b)==c})},w.fragment=function(b,d){d===a&&(d=l.test(b)&&RegExp.$1),d in q||(d="*");var e=q[d];return e.innerHTML=""+b,c.each(f.call(e.childNodes),function(){e.removeChild(this)})},w.Z=function(a,b){return a=a||[],a.__proto__=arguments.callee.prototype,a.selector=b||"",a},w.isZ=function(a){return a instanceof w.Z},w.init=function(b,d){if(!b)return w.Z();if(A(b))return c(g).ready(b);if(w.isZ(b))return b;var e;if(D(b))e=F(b);else if(C(b))e=[c.extend({},b)],b=null;else if(m.indexOf(b.nodeType)>=0||b===window)e=[b],b=null;else if(l.test(b))e=w.fragment(b.trim(),RegExp.$1),b=null;else{if(d!==a)return c(d).find(b);e=w.qsa(g,b)}return w.Z(e,b)},c=function(a,b){return w.init(a,b)},c.extend=function(c){return f.call(arguments,1).forEach(function(d){for(b in d)d[b]!==a&&(c[b]=d[b])}),c},w.qsa=function(a,b){var c;return a===g&&t.test(b)?(c=a.getElementById(RegExp.$1))?[c]:e:a.nodeType!==1&&a.nodeType!==9?e:f.call(s.test(b)?a.getElementsByClassName(RegExp.$1):u.test(b)?a.getElementsByTagName(b):a.querySelectorAll(b))},c.isFunction=A,c.isObject=B,c.isArray=D,c.isPlainObject=C,c.inArray=function(a,b,c){return e.indexOf.call(b,a,c)},c.trim=function(a){return a.trim()},c.uuid=0,c.map=function(a,b){var c,d=[],e,f;if(E(a))for(e=0;e<a.length;e++)c=b(a[e],e),c!=null&&d.push(c);else for(f in a)c=b(a[f],f),c!=null&&d.push(c);return G(d)},c.each=function(a,b){var c,d;if(E(a)){for(c=0;c<a.length;c++)if(b.call(a[c],c,a[c])===!1)return a}else for(d in a)if(b.call(a[d],d,a[d])===!1)return a;return a},c.fn={forEach:e.forEach,reduce:e.reduce,push:e.push,indexOf:e.indexOf,concat:e.concat,map:function(a){return c.map(this,function(b,c){return a.call(b,c,b)})},slice:function(){return c(f.apply(this,arguments))},ready:function(a){return r.test(g.readyState)?a(c):g.addEventListener("DOMContentLoaded",function(){a(c)},!1),this},get:function(b){return b===a?f.call(this):this[b]},toArray:function(){return this.get()},size:function(){return this.length},remove:function(){return this.each(function(){this.parentNode!=null&&this.parentNode.removeChild(this)})},each:function(a){return this.forEach(function(b,c){a.call(b,c,b)}),this},filter:function(a){return c([].filter.call(this,function(b){return w.matches(b,a)}))},add:function(a,b){return c(y(this.concat(c(a,b))))},is:function(a){return this.length>0&&w.matches(this[0],a)},not:function(b){var d=[];if(A(b)&&b.call!==a)this.each(function(a){b.call(this,a)||d.push(this)});else{var e=typeof b=="string"?this.filter(b):E(b)&&A(b.item)?f.call(b):c(b);this.forEach(function(a){e.indexOf(a)<0&&d.push(a)})}return c(d)},eq:function(a){return a===-1?this.slice(a):this.slice(a,+a+1)},first:function(){var a=this[0];return a&&!B(a)?a:c(a)},last:function(){var a=this[this.length-1];return a&&!B(a)?a:c(a)},find:function(a){var b;return this.length==1?b=w.qsa(this[0],a):b=this.map(function(){return w.qsa(this,a)}),c(b)},closest:function(a,b){var d=this[0];while(d&&!w.matches(d,a))d=d!==b&&d!==g&&d.parentNode;return c(d)},parents:function(a){var b=[],d=this;while(d.length>0)d=c.map(d,function(a){if((a=a.parentNode)&&a!==g&&b.indexOf(a)<0)return b.push(a),a});return L(b,a)},parent:function(a){return L(y(this.pluck("parentNode")),a)},children:function(a){return L(this.map(function(){return f.call(this.children)}),a)},siblings:function(a){return L(this.map(function(a,b){return f.call(b.parentNode.children).filter(function(a){return a!==b})}),a)},empty:function(){return this.each(function(){this.innerHTML=""})},pluck:function(a){return this.map(function(){return this[a]})},show:function(){return this.each(function(){this.style.display=="none"&&(this.style.display=null),j(this,"").getPropertyValue("display")=="none"&&(this.style.display=K(this.nodeName))})},replaceWith:function(a){return this.before(a).remove()},wrap:function(a){return this.each(function(){c(this).wrapAll(c(a)[0].cloneNode(!1))})},wrapAll:function(a){return this[0]&&(c(this[0]).before(a=c(a)),a.append(this)),this},unwrap:function(){return this.parent().each(function(){c(this).replaceWith(c(this).children())}),this},clone:function(){return c(this.map(function(){return this.cloneNode(!0)}))},hide:function(){return this.css("display","none")},toggle:function(b){return(b===a?this.css("display")=="none":b)?this.show():this.hide()},prev:function(){return c(this.pluck("previousElementSibling"))},next:function(){return c(this.pluck("nextElementSibling"))},html:function(b){return b===a?this.length>0?this[0].innerHTML:null:this.each(function(a){var d=this.innerHTML;c(this).empty().append(M(this,b,a,d))})},text:function(b){return b===a?this.length>0?this[0].textContent:null:this.each(function(){this.textContent=b})},attr:function(c,d){var e;return typeof c=="string"&&d===a?this.length==0||this[0].nodeType!==1?a:c=="value"&&this[0].nodeName=="INPUT"?this.val():!(e=this[0].getAttribute(c))&&c in this[0]?this[0][c]:e:this.each(function(a){if(this.nodeType!==1)return;if(B(c))for(b in c)this.setAttribute(b,c[b]);else this.setAttribute(c,M(this,d,a,this.getAttribute(c)))})},removeAttr:function(a){return this.each(function(){this.nodeType===1&&this.removeAttribute(a)})},prop:function(b,c){return c===a?this[0]?this[0][b]:a:this.each(function(a){this[b]=M(this,c,a,this[b])})},data:function(b,c){var d=this.attr("data-"+H(b),c);return d!==null?d:a},val:function(b){return b===a?this.length>0?this[0].value:a:this.each(function(a){this.value=M(this,b,a,this.value)})},offset:function(){if(this.length==0)return null;var a=this[0].getBoundingClientRect();return{left:a.left+window.pageXOffset,top:a.top+window.pageYOffset,width:a.width,height:a.height}},css:function(c,d){if(d===a&&typeof c=="string")return this.length==0?a:this[0].style[x(c)]||j(this[0],"").getPropertyValue(c);var e="";for(b in c)typeof c[b]=="string"&&c[b]==""?this.each(function(){this.style.removeProperty(H(b))}):e+=H(b)+":"+J(b,c[b])+";";return typeof c=="string"&&(d==""?this.each(function(){this.style.removeProperty(H(c))}):e=H(c)+":"+J(c,d)),this.each(function(){this.style.cssText+=";"+e})},index:function(a){return a?this.indexOf(c(a)[0]):this.parent().children().indexOf(this[0])},hasClass:function(a){return this.length<1?!1:I(a).test(this[0].className)},addClass:function(a){return this.each(function(b){d=[];var e=this.className,f=M(this,a,b,e);f.split(/\s+/g).forEach(function(a){c(this).hasClass(a)||d.push(a)},this),d.length&&(this.className+=(e?" ":"")+d.join(" "))})},removeClass:function(b){return this.each(function(c){if(b===a)return this.className="";d=this.className,M(this,b,c,d).split(/\s+/g).forEach(function(a){d=d.replace(I(a)," ")}),this.className=d.trim()})},toggleClass:function(b,d){return this.each(function(e){var f=M(this,b,e,this.className);(d===a?!c(this).hasClass(f):d)?c(this).addClass(f):c(this).removeClass(f)})}},["width","height"].forEach(function(b){c.fn[b]=function(d){var e,f=b.replace(/./,function(a){return a[0].toUpperCase()});return d===a?this[0]==window?window["inner"+f]:this[0]==g?g.documentElement["offset"+f]:(e=this.offset())&&e[b]:this.each(function(a){var e=c(this);e.css(b,M(this,d,a,e[b]()))})}}),n.forEach(function(a,b){c.fn[a]=function(){var a=c.map(arguments,function(a){return B(a)?a:w.fragment(a)});if(a.length<1)return this;var d=this.length,e=d>1,f=b<2;return this.each(function(c,g){for(var h=0;h<a.length;h++){var i=a[f?a.length-h-1:h];O(i,function(a){a.nodeName!=null&&a.nodeName.toUpperCase()==="SCRIPT"&&(!a.type||a.type==="text/javascript")&&window.eval.call(window,a.innerHTML)}),e&&c<d-1&&(i=i.cloneNode(!0)),N(b,g,i)}})},c.fn[b%2?a+"To":"insert"+(b?"Before":"After")]=function(b){return c(b)[a](this),this}}),w.Z.prototype=c.fn,w.camelize=x,w.uniq=y,c.zepto=w,c}();window.Zepto=Zepto,"$"in window||(window.$=Zepto),function(a){function f(a){return a._zid||(a._zid=d++)}function g(a,b,d,e){b=h(b);if(b.ns)var g=i(b.ns);return(c[f(a)]||[]).filter(function(a){return a&&(!b.e||a.e==b.e)&&(!b.ns||g.test(a.ns))&&(!d||f(a.fn)===f(d))&&(!e||a.sel==e)})}function h(a){var b=(""+a).split(".");return{e:b[0],ns:b.slice(1).sort().join(" ")}}function i(a){return new RegExp("(?:^| )"+a.replace(" "," .* ?")+"(?: |$)")}function j(b,c,d){a.isObject(b)?a.each(b,d):b.split(/\s/).forEach(function(a){d(a,c)})}function k(b,d,e,g,i,k){k=!!k;var l=f(b),m=c[l]||(c[l]=[]);j(d,e,function(c,d){var e=i&&i(d,c),f=e||d,j=function(a){var c=f.apply(b,[a].concat(a.data));return c===!1&&a.preventDefault(),c},l=a.extend(h(c),{fn:d,proxy:j,sel:g,del:e,i:m.length});m.push(l),b.addEventListener(l.e,j,k)})}function l(a,b,d,e){var h=f(a);j(b||"",d,function(b,d){g(a,b,d,e).forEach(function(b){delete c[h][b.i],a.removeEventListener(b.e,b.proxy,!1)})})}function p(b){var c=a.extend({originalEvent:b},b);return a.each(o,function(a,d){c[a]=function(){return this[d]=m,b[a].apply(b,arguments)},c[d]=n}),c}function q(a){if(!("defaultPrevented"in a)){a.defaultPrevented=!1;var b=a.preventDefault;a.preventDefault=function(){this.defaultPrevented=!0,b.call(this)}}}var b=a.zepto.qsa,c={},d=1,e={};e.click=e.mousedown=e.mouseup=e.mousemove="MouseEvents",a.event={add:k,remove:l},a.proxy=function(b,c){if(a.isFunction(b)){var d=function(){return b.apply(c,arguments)};return d._zid=f(b),d}if(typeof c=="string")return a.proxy(b[c],b);throw new TypeError("expected function")},a.fn.bind=function(a,b){return this.each(function(){k(this,a,b)})},a.fn.unbind=function(a,b){return this.each(function(){l(this,a,b)})},a.fn.one=function(a,b){return this.each(function(c,d){k(this,a,b,null,function(a,b){return function(){var c=a.apply(d,arguments);return l(d,b,a),c}})})};var m=function(){return!0},n=function(){return!1},o={preventDefault:"isDefaultPrevented",stopImmediatePropagation:"isImmediatePropagationStopped",stopPropagation:"isPropagationStopped"};a.fn.delegate=function(b,c,d){var e=!1;if(c=="blur"||c=="focus")a.iswebkit?c=c=="blur"?"focusout":c=="focus"?"focusin":c:e=!0;return this.each(function(f,g){k(g,c,d,b,function(c){return function(d){var e,f=a(d.target).closest(b,g).get(0);if(f)return e=a.extend(p(d),{currentTarget:f,liveFired:g}),c.apply(f,[e].concat([].slice.call(arguments,1)))}},e)})},a.fn.undelegate=function(a,b,c){return this.each(function(){l(this,b,c,a)})},a.fn.live=function(b,c){return a(document.body).delegate(this.selector,b,c),this},a.fn.die=function(b,c){return a(document.body).undelegate(this.selector,b,c),this},a.fn.on=function(b,c,d){return c==undefined||a.isFunction(c)?this.bind(b,c):this.delegate(c,b,d)},a.fn.off=function(b,c,d){return c==undefined||a.isFunction(c)?this.unbind(b,c):this.undelegate(c,b,d)},a.fn.trigger=function(b,c){return typeof b=="string"&&(b=a.Event(b)),q(b),b.data=c,this.each(function(){"dispatchEvent"in this&&this.dispatchEvent(b)})},a.fn.triggerHandler=function(b,c){var d,e;return this.each(function(f,h){d=p(typeof b=="string"?a.Event(b):b),d.data=c,d.target=h,a.each(g(h,b.type||b),function(a,b){e=b.proxy(d);if(d.isImmediatePropagationStopped())return!1})}),e},"focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout change select keydown keypress keyup error".split(" ").forEach(function(b){a.fn[b]=function(a){return this.bind(b,a)}}),["focus","blur"].forEach(function(b){a.fn[b]=function(a){if(a)this.bind(b,a);else if(this.length)try{this.get(0)[b]()}catch(c){}return this}}),a.Event=function(a,b){var c=document.createEvent(e[a]||"Events"),d=!0;if(b)for(var f in b)f=="bubbles"?d=!!b[f]:c[f]=b[f];return c.initEvent(a,d,!0,null,null,null,null,null,null,null,null,null,null,null,null),c}}(Zepto),function(a){function b(a){var b=this.os={},c=this.browser={},d=a.match(/WebKit\/([\d.]+)/),e=a.match(/(Android)\s+([\d.]+)/),f=a.match(/(iPad).*OS\s([\d_]+)/),g=!f&&a.match(/(iPhone\sOS)\s([\d_]+)/),h=a.match(/(webOS|hpwOS)[\s\/]([\d.]+)/),i=h&&a.match(/TouchPad/),j=a.match(/Kindle\/([\d.]+)/),k=a.match(/Silk\/([\d._]+)/),l=a.match(/(BlackBerry).*Version\/([\d.]+)/);if(c.webkit=!!d)c.version=d[1];e&&(b.android=!0,b.version=e[2]),g&&(b.ios=b.iphone=!0,b.version=g[2].replace(/_/g,".")),f&&(b.ios=b.ipad=!0,b.version=f[2].replace(/_/g,".")),h&&(b.webos=!0,b.version=h[2]),i&&(b.touchpad=!0),l&&(b.blackberry=!0,b.version=l[2]),j&&(b.kindle=!0,b.version=j[1]),k&&(c.silk=!0,c.version=k[1]),!k&&b.android&&a.match(/Kindle Fire/)&&(c.silk=!0)}b.call(a,navigator.userAgent),a.__detect=b}(Zepto),function(a,b){function l(a){return a.toLowerCase()}function m(a){return d?d+a:l(a)}var c="",d,e,f,g={Webkit:"webkit",Moz:"",O:"o",ms:"MS"},h=window.document,i=h.createElement("div"),j=/^((translate|rotate|scale)(X|Y|Z|3d)?|matrix(3d)?|perspective|skew(X|Y)?)$/i,k={};a.each(g,function(a,e){if(i.style[a+"TransitionProperty"]!==b)return c="-"+l(a)+"-",d=e,!1}),k[c+"transition-property"]=k[c+"transition-duration"]=k[c+"transition-timing-function"]=k[c+"animation-name"]=k[c+"animation-duration"]="",a.fx={off:d===b&&i.style.transitionProperty===b,cssPrefix:c,transitionEnd:m("TransitionEnd"),animationEnd:m("AnimationEnd")},a.fn.animate=function(b,c,d,e){return a.isObject(c)&&(d=c.easing,e=c.complete,c=c.duration),c&&(c/=1e3),this.anim(b,c,d,e)},a.fn.anim=function(d,e,f,g){var h,i={},l,m=this,n,o=a.fx.transitionEnd;e===b&&(e=.4),a.fx.off&&(e=0);if(typeof d=="string")i[c+"animation-name"]=d,i[c+"animation-duration"]=e+"s",o=a.fx.animationEnd;else{for(l in d)j.test(l)?(h||(h=[]),h.push(l+"("+d[l]+")")):i[l]=d[l];h&&(i[c+"transform"]=h.join(" ")),!a.fx.off&&typeof d=="object"&&(i[c+"transition-property"]=Object.keys(d).join(", "),i[c+"transition-duration"]=e+"s",i[c+"transition-timing-function"]=f||"linear")}return n=function(b){if(typeof b!="undefined"){if(b.target!==b.currentTarget)return;a(b.target).unbind(o,arguments.callee)}a(this).css(k),g&&g.call(this)},e>0&&this.bind(o,n),setTimeout(function(){m.css(i),e<=0&&setTimeout(function(){m.each(function(){n.call(this)})},0)},0),this},i=null}(Zepto),function($){function triggerAndReturn(a,b,c){var d=$.Event(b);return $(a).trigger(d,c),!d.defaultPrevented}function triggerGlobal(a,b,c,d){if(a.global)return triggerAndReturn(b||document,c,d)}function ajaxStart(a){a.global&&$.active++===0&&triggerGlobal(a,null,"ajaxStart")}function ajaxStop(a){a.global&&!--$.active&&triggerGlobal(a,null,"ajaxStop")}function ajaxBeforeSend(a,b){var c=b.context;if(b.beforeSend.call(c,a,b)===!1||triggerGlobal(b,c,"ajaxBeforeSend",[a,b])===!1)return!1;triggerGlobal(b,c,"ajaxSend",[a,b])}function ajaxSuccess(a,b,c){var d=c.context,e="success";c.success.call(d,a,e,b),triggerGlobal(c,d,"ajaxSuccess",[b,c,a]),ajaxComplete(e,b,c)}function ajaxError(a,b,c,d){var e=d.context;d.error.call(e,c,b,a),triggerGlobal(d,e,"ajaxError",[c,d,a]),ajaxComplete(b,c,d)}function ajaxComplete(a,b,c){var d=c.context;c.complete.call(d,b,a),triggerGlobal(c,d,"ajaxComplete",[b,c]),ajaxStop(c)}function empty(){}function mimeToDataType(a){return a&&(a==htmlType?"html":a==jsonType?"json":scriptTypeRE.test(a)?"script":xmlTypeRE.test(a)&&"xml")||"text"}function appendQuery(a,b){return(a+"&"+b).replace(/[&?]{1,2}/,"?")}function serializeData(a){isObject(a.data)&&(a.data=$.param(a.data)),a.data&&(!a.type||a.type.toUpperCase()=="GET")&&(a.url=appendQuery(a.url,a.data))}function serialize(a,b,c,d){var e=$.isArray(b);$.each(b,function(b,f){d&&(b=c?d:d+"["+(e?"":b)+"]"),!d&&e?a.add(f.name,f.value):(c?$.isArray(f):isObject(f))?serialize(a,f,c,b):a.add(b,f)})}var jsonpID=0,isObject=$.isObject,document=window.document,key,name,rscript=/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,scriptTypeRE=/^(?:text|application)\/javascript/i,xmlTypeRE=/^(?:text|application)\/xml/i,jsonType="application/json",htmlType="text/html",blankRE=/^\s*$/;$.active=0,$.ajaxJSONP=function(a){var b="jsonp"+(++jsonpID),c=document.createElement("script"),d=function(){$(c).remove(),b in window&&(window[b]=empty),ajaxComplete("abort",e,a)},e={abort:d},f;return a.error&&(c.onerror=function(){e.abort(),a.error()}),window[b]=function(d){clearTimeout(f),$(c).remove(),delete window[b],ajaxSuccess(d,e,a)},serializeData(a),c.src=a.url.replace(/=\?/,"="+b),$("head").append(c),a.timeout>0&&(f=setTimeout(function(){e.abort(),ajaxComplete("timeout",e,a)},a.timeout)),e},$.ajaxSettings={type:"GET",beforeSend:empty,success:empty,error:empty,complete:empty,context:null,global:!0,xhr:function(){return new window.XMLHttpRequest},accepts:{script:"text/javascript, application/javascript",json:jsonType,xml:"application/xml, text/xml",html:htmlType,text:"text/plain"},crossDomain:!1,timeout:0},$.ajax=function(options){var settings=$.extend({},options||{});for(key in $.ajaxSettings)settings[key]===undefined&&(settings[key]=$.ajaxSettings[key]);ajaxStart(settings),settings.crossDomain||(settings.crossDomain=/^([\w-]+:)?\/\/([^\/]+)/.test(settings.url)&&RegExp.$2!=window.location.host);var dataType=settings.dataType,hasPlaceholder=/=\?/.test(settings.url);if(dataType=="jsonp"||hasPlaceholder)return hasPlaceholder||(settings.url=appendQuery(settings.url,"callback=?")),$.ajaxJSONP(settings);settings.url||(settings.url=window.location.toString()),serializeData(settings);var mime=settings.accepts[dataType],baseHeaders={},protocol=/^([\w-]+:)\/\//.test(settings.url)?RegExp.$1:window.location.protocol,xhr=$.ajaxSettings.xhr(),abortTimeout;settings.crossDomain||(baseHeaders["X-Requested-With"]="XMLHttpRequest"),mime&&(baseHeaders.Accept=mime,mime.indexOf(",")>-1&&(mime=mime.split(",",2)[0]),xhr.overrideMimeType&&xhr.overrideMimeType(mime));if(settings.contentType||settings.data&&settings.type.toUpperCase()!="GET")baseHeaders["Content-Type"]=settings.contentType||"application/x-www-form-urlencoded";settings.headers=$.extend(baseHeaders,settings.headers||{}),xhr.onreadystatechange=function(){if(xhr.readyState==4){clearTimeout(abortTimeout);var result,error=!1;if(xhr.status>=200&&xhr.status<300||xhr.status==304||xhr.status==0&&protocol=="file:"){dataType=dataType||mimeToDataType(xhr.getResponseHeader("content-type")),result=xhr.responseText;try{dataType=="script"?(1,eval)(result):dataType=="xml"?result=xhr.responseXML:dataType=="json"&&(result=blankRE.test(result)?null:JSON.parse(result))}catch(e){error=e}error?ajaxError(error,"parsererror",xhr,settings):ajaxSuccess(result,xhr,settings)}else ajaxError(null,"error",xhr,settings)}};var async="async"in settings?settings.async:!0;xhr.open(settings.type,settings.url,async);for(name in settings.headers)xhr.setRequestHeader(name,settings.headers[name]);return ajaxBeforeSend(xhr,settings)===!1?(xhr.abort(),!1):(settings.timeout>0&&(abortTimeout=setTimeout(function(){xhr.onreadystatechange=empty,xhr.abort(),ajaxError(null,"timeout",xhr,settings)},settings.timeout)),xhr.send(settings.data?settings.data:null),xhr)},$.get=function(a,b){return $.ajax({url:a,success:b})},$.post=function(a,b,c,d){return $.isFunction(b)&&(d=d||c,c=b,b=null),$.ajax({type:"POST",url:a,data:b,success:c,dataType:d})},$.getJSON=function(a,b){return $.ajax({url:a,success:b,dataType:"json"})},$.fn.load=function(a,b){if(!this.length)return this;var c=this,d=a.split(/\s/),e;return d.length>1&&(a=d[0],e=d[1]),$.get(a,function(a){c.html(e?$(document.createElement("div")).html(a.replace(rscript,"")).find(e).html():a),b&&b.call(c)}),this};var escape=encodeURIComponent;$.param=function(a,b){var c=[];return c.add=function(a,b){this.push(escape(a)+"="+escape(b))},serialize(c,a,b),c.join("&").replace("%20","+")}}(Zepto),function(a){a.fn.serializeArray=function(){var b=[],c;return a(Array.prototype.slice.call(this.get(0).elements)).each(function(){c=a(this);var d=c.attr("type");this.nodeName.toLowerCase()!="fieldset"&&!this.disabled&&d!="submit"&&d!="reset"&&d!="button"&&(d!="radio"&&d!="checkbox"||this.checked)&&b.push({name:c.attr("name"),value:c.val()})}),b},a.fn.serialize=function(){var a=[];return this.serializeArray().forEach(function(b){a.push(encodeURIComponent(b.name)+"="+encodeURIComponent(b.value))}),a.join("&")},a.fn.submit=function(b){if(b)this.bind("submit",b);else if(this.length){var c=a.Event("submit");this.eq(0).trigger(c),c.defaultPrevented||this.get(0).submit()}return this}}(Zepto),function(a){function d(a){return"tagName"in a?a:a.parentNode}function e(a,b,c,d){var e=Math.abs(a-b),f=Math.abs(c-d);return e>=f?a-b>0?"Left":"Right":c-d>0?"Up":"Down"}function h(){g=null,b.last&&(b.el.trigger("longTap"),b={})}function i(){g&&clearTimeout(g),g=null}var b={},c,f=750,g;a(document).ready(function(){var j,k;a(document.body).bind("touchstart",function(e){j=Date.now(),k=j-(b.last||j),b.el=a(d(e.touches[0].target)),c&&clearTimeout(c),b.x1=e.touches[0].pageX,b.y1=e.touches[0].pageY,k>0&&k<=250&&(b.isDoubleTap=!0),b.last=j,g=setTimeout(h,f)}).bind("touchmove",function(a){i(),b.x2=a.touches[0].pageX,b.y2=a.touches[0].pageY}).bind("touchend",function(a){i(),b.isDoubleTap?(b.el.trigger("doubleTap"),b={}):b.x2&&Math.abs(b.x1-b.x2)>30||b.y2&&Math.abs(b.y1-b.y2)>30?(b.el.trigger("swipe")&&b.el.trigger("swipe"+e(b.x1,b.x2,b.y1,b.y2)),b={}):"last"in b&&(b.el.trigger("tap"),c=setTimeout(function(){c=null,b.el.trigger("singleTap"),b={}},250))}).bind("touchcancel",function(){c&&clearTimeout(c),g&&clearTimeout(g),g=c=null,b={}})}),["swipe","swipeLeft","swipeRight","swipeUp","swipeDown","doubleTap","tap","singleTap","longTap"].forEach(function(b){a.fn[b]=function(a){return this.bind(b,a)}})}(Zepto);
if (typeof define === 'function' && define.amd) {
  define('jquery',[],function() { return Zepto; });
}
;
define("Backward", ["jquery"], function($) {
	/**
	 * Converts old banners into new format needed for slideshow.
	 * This function should be removed when all the pages containing banners are updated.
	 */
	function banners() {
		var bannerContainer = document.getElementById("banner-container");
		if (!bannerContainer) {
			// no banner found on page, do nothing
			return; 
		}
		var banner = document.getElementById("banner");
		if (!banner) {
			return;
		}
		// update CSS class
		banner.className = "slideshow sliding";
		
		// remove old navigation, if exists
		var nav = banner.getElementsByTagName("DIV")[0];
		if (nav) {
			banner.removeChild(nav);
		}
		
		// get slides
		var slidesContainer = banner.getElementsByTagName("UL");
		if (!slidesContainer) {
			return;
		}
		slidesContainer = banner.getElementsByTagName("UL")[0];
		var slides = slidesContainer.getElementsByTagName("LI");
		// transform LI in DIV elements
		for (var i = 0, n = slides.length; i < n; i++) {
			var newSlide = document.createElement("DIV");
			newSlide.innerHTML = slides[i].innerHTML;
			banner.appendChild(newSlide);
		}
		// remove old slides
		banner.removeChild(slidesContainer);
		
		// add new navigation
		var newNav = document.createElement("DIV");
		newNav.id = "bannerNav";
		newNav.className = "nextPrevNav";
		newNav.innerHTML = 
			'<a href="#banner/previous" class="slideshowNav previous" data-cycle="true" data-interval="bannerPlay:stop">&lt;</a>' +
			'<a href="#banner/next" class="slideshowNav next" data-cycle="true" data-interval="bannerPlay:stop">&gt;</a>' + 
			'<a href="#banner/next" class="slideshowNav invisible" data-cycle="true" data-interval="bannerPlay:autostart/5000">play</a>';
			'<a href="#banner/next" class="slideshowNav invisible" data-invoke-on="swipe-x" data-swipe-delta="100" data-for="banner"></a>' +
			'<a href="#banner/previous" class="slideshowNav invisible" data-invoke-on="swipe-x" data-swipe-delta="-100" data-for="banner"></a>';
			
		bannerContainer.appendChild(newNav);
	}

	return {
		all: function() {
			banners();
		}
	}
});

define("NodeUtils", [], function() {
	"use strict"
	var BROWSER_PREFIXES = ["Moz", "Webkit", "O", "ms"];
	
	var NodeUtils = {
	
	/**
	 * @param nodeCollection a collection of nodes
	 * @param nodeToFind the node to be find in the given collection
	 * @return the index of the node, 0 based, or -1 if not found
	 */
	indexOfNode: function(nodeCollection, nodeToFind) {
		for (var i = 0, n = nodeCollection.length; i < n; i++) {
			if (nodeCollection[i] == nodeToFind) {
				return i;
			}
		}
		return -1;
	},
	
	/**
	 * Returns true if o is a DOM node.
	 * @param o the object to check
	 */
	isNode : function (o) {
		if (typeof Node === "object") { 
			// if the Node object is defined in the browser, check directly against that
			return o instanceof Node; 
		} else {
			// if not, check that the object has nodeType and nodeName set
			return (o && typeof o === "object" && typeof o.nodeType === "number" && typeof o.nodeName === "string");
		}
	},
	
	/**
	 * Return true if the supplied object is a DOM TextNode, false otherwise.
	 */
	isTextNode : function (node) {
		return this.isNode(node) && node.nodeType === 3;
	},
	
	/**
	 * Returns true if o is a DOM element.
	 * @param o the object to check
	 */
	isElement : function (o) {
		if (typeof HTMLElement === "object") {
			return o instanceof HTMLElement;
		} else {
			return (this.isNode(o) && o.nodeType === 1);
		}
	},	
	
	getLevel : function(node, parentProperty) {
		if (!parentProperty) {
			parentProperty = "parentNode";
		}
			
		var level = -1;
		do {
			level++;
			node = node[parentProperty];
		} while (node);
		return level;
	},
	
	getLowestCommonAncestor : function(node1, node2, parentProperty) {
		if (!node1 || !node2) {
			return null;
		}
		if (!parentProperty) {
			parentProperty = "parentNode";
		}
		var l1 = this.getLevel(node1, parentProperty);
		var l2 = this.getLevel(node2, parentProperty);
		for (var l = l1 - l2; l > 0; l--) {
			node1 = node1[parentProperty];
		}
		for (var l = l2 - l1; l > 0; l--) {
			node2 = node2[parentProperty];
		}
		while (node1 != node2) {
			node1 = node1[parentProperty];
			node2 = node2[parentProperty];
		}
		return node1;
	},

	/**
	 * Find form of the element that triggered the event and submit it. This method can be used as an event handler.
	 * @param source the event or the element itself
	 */
	triggerFormSubmit : function(source) {
		var $form = $(source.target ? source.target : source).parents("FORM");
		var form = $form.length > 0 ? $form[0] : null;
		if (form) {
			if (source.type == 'keypress') {
				if (source.keyCode == 13)
					form.submit();
			} else {
				form.submit();
			}
		}
	},
	
	/** If an element has defined the {@code data-copyOf} attribute then its content will be the same as the element
	 * with the id specified in {@code data-copyOf} attribute. 
	 * The source element must be a field and its value will be duplicated.
	 * This method will enable this feature on the given elements.
	 * @param element the element on which to enable this feature. 
	 * If it is a list of elements, it enables on all the elements.
	 * If it is a string it enables on the element with this id.
	 * If not specified, does nothing.
	 */
	enableCopyOf : function(element) {
		if (element == null)
			return;
		if (element.ownerDocument) {
			var copyOfId = element.getAttribute("data-copyOf");
			var copyOf = element.ownerDocument.getElementById(copyOfId);
			if (copyOf != null && copyOf.value) {
				var handler = function() {
					if (element.value) {
						element.value = copyOf.value;
					} else {
						element.innerHTML = copyOf.value;
					}
				}
				copyOf.on("input change", handler);
			}
		} else if (element.length) {
			for (var i = 0, n = element.length; i < n; i++) {
				this.enableCopyOf(element[i]);
			}
		} else if (element.substring) {
			this.enableCopyOf(document.getElementById(element));
		}
	},

	setBrowserSpecificStyle : function(element, property, value) {
		var propertyTitleCase = property.substring(0, 1).toUpperCase() + property.substring(1);
		for (var i = 0; i < BROWSER_PREFIXES.length; i++) {
			element.style[BROWSER_PREFIXES[i] + propertyTitleCase] = value;
		}
		element.style[property] = value;
	}

	};
	
	return NodeUtils;
});

define("StringUtils", {

	/**
	 * Checks if the string starts with the given prefix.
	 */
	startsWith : function(s, prefix) {
	    return s.indexOf(prefix) === 0;
	},

	/**
	 * Checks if the string ends with the given suffix.
	 */
	endsWith : function(s, suffix) {
	    var d = s.length - suffix.length;
	    return d >= 0 && s.lastIndexOf(suffix) === d;
	}, 
	
	escapeQuotes : function(str) {
	    str = str.replace(/"/g, '\\"');
	    return str;
	},
	
	findAll : function (needle, haystack, caseSensitive) {
		var indices = [], startIndex = 0, needleLength = needle.length;
		if (caseSensitive !== true) {
			haystack = haystack.toLowerCase();
			needle = needle.toLowerCase();
		}
		while ((index = haystack.indexOf(needle, startIndex)) > -1) {
			indices.push(index);
			startIndex = index + needleLength;
		}
		return indices;
	},
	
	toTitleCase : function (str) {
		return str ? str.charAt(0).toUpperCase() + str.slice(1) : str;
	}
});

function isWhiteSpace(ch) {
	return ch == ' ' || ch == '\t' || ch == '\n' || ch == '\r';
}

// define trim() for strings - for IE7 it is too complicated of an operation
if (!String.prototype.trim) {
	String.prototype.trim = function() {
		if (this.charAt) {
			var n = this.length, trimLeft = 0, trimRight = n - 1;
			while (trimLeft < n && isWhiteSpace(this.charAt(trimLeft))) trimLeft++;
			while (trimRight > trimLeft && isWhiteSpace(this.charAt(trimRight))) trimRight--;
			trimRight++;
			if (trimLeft > 0 || trimRight < n) {
				return this.substring(trimLeft, trimRight);
			} else {
				return this;
			}
		}
	};
}
;
define("HPUtils", ["jquery", "StringUtils", "NodeUtils"], 
		function ($, StringUtils, NodeUtils) {
	
	/**
	 * Return version of IE or null if IE is not detected
	 */
	function getInternetExplorerVersion() {
		var version = null;
		if (navigator && navigator.appName == 'Microsoft Internet Explorer') {
			var ua = navigator.userAgent;
			var re = new RegExp("MSIE\s([\d]+)");
			if (re.exec(ua) != null) {
				version = parseFloat(RegExp.$1);
			}
		}
		return version;
	};

	var moduleAttr = $("html").data("modules"), 
		activeModules = moduleAttr ? moduleAttr.split(",") : [];
		
	function resizeNavs() {
        $(".nav[id]").each(function (index, nav) {
			var $nav = $(nav);
        	//$nav.height($nav.parent().nextAll("DIV:first").height());
			// calculate the nav menu height as being the maximum value between 
			// the height of its first chil (we suppose that there is only one)
			// and the height of the DIV next to it (again supposing there is only one), supposedly the content
			$nav.height(Math.max($nav.nextAll("DIV:first").height(), $nav.find("> *").height()));
        });
	}
	
	var fixCounter = 0;
	
	var Locale = function(language, country) {
		if (language == null) {
			language = "";
		}
		if (country == null) {
			var parts = language.split("-");
			language = parts[0];
			country = parts[1];
		}
		this.language = language;
		this.country = country;
	}
	
	Locale.prototype.toString = function() { 
		return this.language + (this.country ? "-" + this.country : "");
	};
	
	/**
	 * hp uses regions and some country names in Hp are different from what we get from bing
	 * this map has entries on which the key is the is the region or country specific to Hp, and the value is the country name coming from bing  
	 */
	var COUNTRY_ALIASES = {
			"Caribbean" : ["Antigua and Barbuda", "Aruba", "The Bahamas", "Barbados", "Cayman Islands", "Cuba", "Dominica", "Dominican Republic",
			               "Grenada", "French-Guadeloupe", "Haiti", "Jamaica", "French-Martinique", "Saint Barthelemy", "Saint Lucia",
			               "Saint Vincent and the Grenadines", "Trinidad and Tobago", "Turks and Caicos Islands", "British Virgin Islands", "US Virgin Islands"],
			               
			"América Central": ["Belice", "Costa Rica", "El Salvador", "Guatemala", "Honduras", "México", "Nicaragua", "Panama", "Panamá"],
			
			"Africa": ["Burundi", "Comoros", "Djibouti", "Eritrea", "Ethiopia", "Kenya", "Madagascar", "Malawi", "Mauritius", "Mayotte", "Mozambique",
			           "Reunion", "Rwanda", "Seychelles", "Somalia", "Tanzania", "Uganda", "Zambia", "Zimbabwe", "Angola", "Cameroon", "Central African Republic",
			           "Chad", "Congo (RDC)", "Equatorial Guinea", "Gabon", "São Tomé and Príncipe", "Algeria", "Egypt", "Libya", "South Sudan", "Sudan",
			           "Tunisia", "Botswana", "Lesotho", "Namibia", "Swaziland", "Benin", "Burkina Faso", "Cape Verde", "Ivory Coast", "Gambia", "Ghana",
			           "Guinea", "Guinea-Bissau", "Liberia", "Mali", "Mauritania", "Niger", "Nigeria", "Saint-Helena", "Senegal", "Sierra Leone", "Togo"],
			           
			"Afrique": ["Burundi", "Comores", "Djibouti", "Érythrée", "Éthiopie", "Kenya", "Madagascar", "Malawi", "Maurice", "Mayotte", "Mozambique", 
			            "Réunion-France", "Rwanda", "Seychelles", "Somalie", "Tanzanie", "Ouganda", "Zambie", "Zimbabwe", "Angola", "Cameroun", 
			            "République centrafricaine", "Tchad", "République du Congo", "Congo (RDC)", "Guinée équatoriale", "Gabon", "Sao Tomé-et-Principe", 
			            "Algérie", "Égypte", "Libye", "Soudan du Sud", "Soudan", "Tunisie", "Botswana", "Lesotho", "Namibie", "Swaziland", "Bénin",
			            "Burkina", "Cap-Vert", "Côte d'Ivoire", "Gambie", "Ghana", "Guinée", "Guinée-Bissau", "Libéria", "Mali", "Mauritanie", "Niger",
			            "Nigéria", "Sainte-Hélène", "Sénégal", "Sierra Leone", "Togo"],
			
			"Middle East": ["Iran", "Turkey", "Iraq", "Saudi Arabia", "Yemen", "Syria", "United Arab Emirates", "Jordan", "Lebanon", "Oman", "Kuwait", "Qatar", 
			                "Bahrain", "Cyprus"],
			
			"الشرق الأوسط": ["إيران", "تركيا", "العراق", "السعودية", "اليمن", "سورية", "الإمارات العربية المتحدة", "الأردن", "لبنان", "عمان", "الكويت", "قطر", "البحرين", "قبرص" ],
			
			"Slovensko": ["Slovenská republika"],
			"Hong Kong": ["Hong Kong SAR"],
			"香港": ["香港特别行政区"],
			"한국": ["대한민국"],
			"België": ["Luxemburg"],
			"Belgique": ["Luxembourg"],
			"Ελλάδα": ["Κύπρος"],
			"臺灣": ["台灣"]
		};
	for (var x in COUNTRY_ALIASES) {
		COUNTRY_ALIASES[x.toUpperCase()] = $.each(COUNTRY_ALIASES[x], function(index, item) {
			COUNTRY_ALIASES[x][index] = item.toUpperCase();
		});
	}
	
return {
		
	INVISIBLE_CLASS : "invisible",	
	LOADING_CLASS : "loading",
	CLASS_HIGHLIGHT : "highlight",
	
	/**
	 * Hide the element node.
	 */
	hide : function(node) {
		$(node).addClass(this.INVISIBLE_CLASS);
	},
	
	/**
	 * Show the element node.
	 */
	show : function(node) {
		$(node).removeClass(this.INVISIBLE_CLASS);
	},
	
	setSiteLabels : function(labels) {
		window.siteLabels = labels;
	},
	
	setSearchFilters : function(searchFilters) {
		window.searchFilters = searchFilters;
	},
	
	/**
	 * Add events to auto submit form when elements state was changed. Submit button
	 * will be hidden. Only inputs with attribute 'data-submit-id' are considered.
	 */
	enableAutoSubmit : function(element) {
		if (element == null)
			element = document;
		
		var ID_ATTR = 'data-submit-id';
		
		if (element.form) {
			// if the element is a form field
			var submitId = element.getAttribute(ID_ATTR);
			if (submitId != null) {
				var submit = element.ownerDocument.getElementById(submitId);
				// TODO better put the invisble class on the submit directly
				this.hide(submit);
				var event = "change";
				if (element.tagName == "INPUT") {
					if (element.type == 'radio' || element.type == 'checkbox') {
						event = "click";
					} else if (element.type == 'text') {
						event = "keypress";
					}
				}
				$(element).on(event, NodeUtils.triggerFormSubmit);
			}
		} else if(element.getElementsByTagName) {
			// if the element is a document
			var HPUtils = this;
			$("SELECT[data-submit-id], INPUT[data-submit-id]").each(function() {
				HPUtils.enableAutoSubmit(this);
			});
		}
	},
	
	highlightNonEmptyFields : function(selector) {
		var that = this;
		// TODO should we highlight non-empty fields on start or only after editing them
		$(document).on("blur", selector || "input[type=text], textarea, select", function(e) {
			if ($(e.target).val()) {
				// need to keep a reference to this, because we're calling
				// this from inside a callback with a different context
				$(e.target).addClass(that.CLASS_HIGHLIGHT);
			}
		});
	},
	
	initFilterSwitches : function() {
		$("ul[filters-list='true'] li input:checked").parent('li').addClass('selected');
		$(document).on("click", "ul[filters-list=true] li input", function(e) {
			$("ul[filters-list=true] li input").parent('li').removeClass('selected');
			$("ul[filters-list=true] li input:checked").parent('li').addClass('selected');
		});
	},
	
	initNavs: function() {
        $(".nav[id]").each(function (index, nav) {
			var $nav = $(nav);
        	//$nav.wrap("<div id='" + nav.id + "-container' class='navContainer'/>");
			//$nav.parent().after("<a href='#" + nav.id + "-container' class='navExpander expanded'></a>");
			$nav.after("<a href='#" + nav.id + "' class='navExpander expanded'></a>");
			// TODO register this only once per document and do it on the expand/collapse event
			//$nav.on("click", "A", resizeNavs);
			//$nav.find("INPUT.expanded, INPUT.collapsed").change(resizeNavs);
		});
        
        $(window).on("resize", resizeNavs);
        $(window).on("load", resizeNavs);
	},
	
	/** Get current coordinates and pass them as params for the given location element. */
	updateLocationLink : function(elem) {
		if (!elem && navigator.geolocation) {
			navigator.geolocation.getCurrentPosition(function(position) {
				var lat = position.coords.latitude;
				var lon = position.coords.longitude;
				var originalHref = elem.getAttribute("data-href");
				if (!originalHref) {
					originalHref = elem.href;
					elem.setAttribute("data-href", originalHref);
				}
				elem.href = originalHref.replace("{lat}", lat).replace("{lon}", lon);
			});
		}
	},
	
	/** Given an array of DOM ids, returns an array of
	 * corresponding DOM elements. */
	getElementsByIds : function (ids) {
		var results = $([]);
		// using a composite selector #id,#id2 does not work because it doesn't preserve order
		$.each(ids, function (idx, val) { 
			results.push($('#' + val)[0]);
		});
		return results;
	},
	
	/**
	 * Return true if used browser is IE
	 */
	isIE : function () { 
		return getInternetExplorerVersion() != null;
	},
	
	enable : function(inputs, enabled) {
		var $inputs = $(inputs);
		if (enabled != false) {
    		$inputs.removeClass("disabled");
    		$inputs.each(function () { 
    			this.disabled = false;
    		})
    	} else {
    		$inputs.addClass("disabled");
    		$inputs.each(function () {
    			this.disabled = true;
    		});
    	}
	},
	
	/**
	 * Returns the name of the dominant initialization function
	 * in a certain module (object). Right now, the precedence
	 * is initAll > init. 
	 */
	getInitFuncName : function (module) {
		var initFuncNames = ['initAll', 'init'], initFuncName;
		$.each(initFuncNames, function (idx, funcName) {
			if (typeof module[funcName] === 'function') {
				initFuncName = funcName;
				return false;
			} 
		});
		return initFuncName;
	},
	
	/**
	 * Calls a module's initialization function, if the module
	 * should be activated in a given page.
	 */
	initModule : function (module) {
		var initFuncName = this.getInitFuncName(module);
		if (initFuncName) {
			if (module.checkForInit) {
				 if ($.inArray(module.id, activeModules) === -1) {
					 return false;
				 }
			}
			var result = module[initFuncName]();
			return result ? result : true;
		}
		return false;
	},
	
	/**
	 * Uses the initModule function on an array of modules.
	 */
	initModules : function (modules) {
		var thisObj = this;
		$.each(modules, function (idx, module) {
			thisObj.initModule(module);
		});
	},

	/** 
	 * Used to fix repaint issue for some browser: Safari v5, some versions of Firefox (page is not refreshed after class was updated)
	 */
	triggerReflow: function () {
		if (fixCounter++ % 2 == 0) {
			$(document).addClass(".dummy");
		} else {
			$(document).removeClass(".dummy");
		}
		
//		 try {
//        	document.styleSheets[0].addRule('.dummy', 'position: relative'); 
//        } catch(e) {}

// TODO: check this function for IE before remove
//		// trigger reflow in IE; IE we love you!
//		document.body.className = document.body.className;
	},
	
	getLocaleCode: function() {
		return new Locale($("html").attr("lang"));
	},
	
	/**
	 * checks if the two countries have the same name, or there is an exeption for them in COUNTRY_ALIASES
	 */
	sameCountry: function(country1, country2) {
		if (!country1 || !country2)
			return false;
		country1 = country1.toUpperCase();
		country2 = country2.toUpperCase();
		return (country1 == country2 || 
			(COUNTRY_ALIASES[country1] && $.inArray(country2, COUNTRY_ALIASES[country1]) > -1) ||
			(COUNTRY_ALIASES[country2] && $.inArray(country1, COUNTRY_ALIASES[country2]) > -1));
	}
};
});

define("Fix", ["jquery", "StringUtils"], function($, StringUtils) {
	var labelClick = function(event) {
		el = event.target.ownerDocument.getElementById(event.target.getAttribute('for'));
		if (el == null) {
			return;
		}
		if (['radio', 'checkbox'].indexOf(el.getAttribute('type')) != -1) {
			el.setAttribute('selected', !el.getAttribute('selected'));
		} else {
			el.focus();
		}
	};

	var fixLabelClickEvent = function(doc) {
		$("LABEL[for]").click(labelClick);
	};

	/** Fix viewport when device orientation is changed and zoom is enabled. */
	var fixViewport = function (doc) {
		var event = 'gesturestart',
		    qsa = 'querySelectorAll',
		    scales = [1, 1], //initial scale width and height
		    meta = qsa in doc ? doc[qsa]('meta[name=viewport]') : [],
		    _fix = function (event) {
				meta.content = 'width=device-width,minimum-scale=' + scales[0] + ',maximum-scale=' + scales[1];
				doc.removeEventListener(event, _fix, true);
			}

		if ((meta = meta[meta.length - 1])) {
			_fix();	
			// enable zoom when gestures starts
			scales = [.25, 1.6];
			$(doc).on(event, _fix);
		}
	};
	
	var iPhone = function() {
		if (!navigator.userAgent.match(/iPhone|iPod|iPad/)) 
			return;
		
		fixLabelClickEvent(document);
		fixViewport(document);
		
	};
		
	return {
		all: function() {
			iPhone();
		}
	}

});


/**
 * This is a workaround for implementing .required:before using CSS expressions in IE7.
 * It should be used like this in CSS {@code background-image: expression(addRequiredBeforeForIE7(this));}
 * @param element the element that has required
 * @returns {String} returns the value for background image
 */
function addRequiredBeforeForIE7(element) {
	if (!element.firstChild || element.firstChild.tagName != "SPAN") {
		var star = element.ownerDocument.createElement("SPAN");
		star.className = "required";
		star.innerHTML = "*";
		if (element.firstChild)
			element.insertBefore(star, element.firstChild);
		else
			element.appendChild(star);
	}
	return "none";
}
;
// copied from https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf
if (!Array.prototype.indexOf) {  
    Array.prototype.indexOf = function (searchElement /*, fromIndex */ ) {  
          
        if (this == null) {  
            throw new TypeError();  
        }  
        var t = Object(this);  
        var len = t.length >>> 0;  
        if (len === 0) {  
            return -1;  
        }  
        var n = 0;  
        if (arguments.length > 0) {  
            n = Number(arguments[1]);  
            if (n != n) { // shortcut for verifying if it's NaN  
                n = 0;  
            } else if (n != 0 && n != Infinity && n != -Infinity) {  
                n = (n > 0 || -1) * Math.floor(Math.abs(n));  
            }  
        }  
        if (n >= len) {  
            return -1;  
        }  
        var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);  
        for (; k < len; k++) {  
            if (k in t && t[k] === searchElement) {  
                return k;  
            }  
        }  
        return -1;  
    }  
}

// Production steps of ECMA-262, Edition 5, 15.4.4.18  
// Reference: http://es5.github.com/#x15.4.4.18  
if ( !Array.prototype.forEach ) {  
  
  Array.prototype.forEach = function( callback, thisArg ) {  
  
    var T, k;  
  
    if ( this == null ) {  
      throw new TypeError( " this is null or not defined" );  
    }  
  
    // 1. Let O be the result of calling ToObject passing the |this| value as the argument.  
    var O = Object(this);  
  
    // 2. Let lenValue be the result of calling the Get internal method of O with the argument "length".  
    // 3. Let len be ToUint32(lenValue).  
    var len = O.length >>> 0; // Hack to convert O.length to a UInt32  
  
    // 4. If IsCallable(callback) is false, throw a TypeError exception.  
    // See: http://es5.github.com/#x9.11  
    if ( {}.toString.call(callback) != "[object Function]" ) {  
      throw new TypeError( callback + " is not a function" );  
    }  
  
    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.  
    if ( thisArg ) {  
      T = thisArg;  
    }  
  
    // 6. Let k be 0  
    k = 0;  
  
    // 7. Repeat, while k < len  
    while( k < len ) {  
  
      var kValue;  
  
      // a. Let Pk be ToString(k).  
      //   This is implicit for LHS operands of the in operator  
      // b. Let kPresent be the result of calling the HasProperty internal method of O with argument Pk.  
      //   This step can be combined with c  
      // c. If kPresent is true, then  
      if ( k in O ) {  
  
        // i. Let kValue be the result of calling the Get internal method of O with argument Pk.  
        kValue = O[ k ];  
  
        // ii. Call the Call internal method of callback with T as the this value and  
        // argument list containing kValue, k, and O.  
        callback.call( T, kValue, k, O );  
      }  
      // d. Increase k by 1.  
      k++;  
    }  
    // 8. return undefined  
  };  
} 

define("JSUtils", {
	
	randomInt : function(min, max) {  
		return Math.floor(Math.random() * (max - min + 1)) + min;  
	},
	
	/** Removes the given element from this array.
	 * @param element the element to be searched 
	 * @return the index of the first element removed 
	 */
	removeElementFromArray : function(array, element) {
	    var idx = array.indexOf(element);
	    var firstIndex = idx;
	    while (idx >= 0) {
	        array.splice(idx, 1);
	        idx = array.indexOf(element);
	    }
	    return firstIndex;
	},
	
	/** Adds all elements from the second array to the first one. Unlike concat this modifies the first argument. 
	 * @return the first array
	 */
	addAll : function(targetArray, sourceArray) {
		for (var i = 0; i < sourceArray.length; i++) {
			targetArray.push(sourceArray);
		}
		return targetArray;
	},
	
	forEach : function(nodes, callback) {
		Array.prototype.forEach.call(nodes, callback);
	}

});

define("WindowUtils", [ "jquery", "NodeUtils"], function($, NodeUtils) {

	var SEPARATOR = ",";
	var POSITIONING = {AUTO : "auto", 
		ABOVE : "above", BELLOW : "bellow", LEFT : "left", RIGHT : "right", 
		CENTER : "center", SCROLL : "scroll", FIXED : "fixed"};
	
	var WindowUtils = {
	
	isTouchDevice : function (win) {
		if (!win) {
			win = window;
		}
		return "ontouchstart" in win;
	},
	
	/** @return if the given position is in the current scroll area */
	isVisible : function(position) {
		var win = window;
		var $win = $(win);
		var currentScroll = {top: $win.scrollTop(), left: $win.scrollLeft()};
		return !(position.top < currentScroll.top || position.top > currentScroll.top + $win.height()
				|| position.left < currentScroll.left || position.left > currentScroll.left + $win.width());
	},
	
	/**
	 * Smooth scrolling until the given destination, only if not already visible. 
	 * Smooth scrolling is useful to simulate the transition instead of directly jumping to the element.
	 * @param position the offset in pixels of the destination, relative to the entire page. this object 
	 * has top and left properties defined
	 * @param force force the scroll even if the given position is visible.
	 */
	scrollSmooth : function(position, force) {
		var win = window;
		var $win = $(win);
		var currentScroll = {top: $win.scrollTop()};

		// if already visible and we're not forced to scroll
		if (force != true && this.isVisible(position)) {
			return;
		}
		
		// if the current YOffset could not be determined, scroll to it
		if (typeof currentScroll.top != 'number') win.scrollTo(position.left, position.top);
		
		var intervalId = win.setInterval(function () {
			var distance = {top: position.top - currentScroll.top, 
					left: position.left - currentScroll.left}, 
				offset = 
					{top: (Math.abs(distance.top) > 100) 
						? 100 * distance.top / Math.abs(distance.top) 
						: distance.top,
					left: (Math.abs(distance.left) > 100) 
						? 100 * distance.left / Math.abs(distance.left) 
						: distance.left}
				;
			
			if (Math.abs(distance) != 0) {
				win.scrollBy(offset.left, offset.top);
				currentScroll.top = currentScroll.top + offset.top;
				currentScroll.left = currentScroll.left + offset.left;
			} else {
				win.clearInterval(intervalId);
			}
		}, 200);
	},
	
	getWindowFor : function (element) {
		return 'defaultView' in element ? element.defaultView : element.parentWindow;		
	},
	
	/**
	 * Returns the offset as an object with top and left properties of the given element relative to an ancestor.
	 * @param element the element to calculate the offset for
	 * @param reference the ancestor in which reference we calculate the offset. If null or it is not an ancestor
	 * the offset relative to the entire document is returned. If this is the same as the element, the offset is 
	 * considered 0 on both axis.
	 */
	getOffsetRelativeTo : function(element, reference) {
		var offset = { top: 0, left: 0 };
		while (element != reference && element && !isNaN(element.offsetLeft) && !isNaN(element.offsetTop)) {
			offset.top += element.offsetTop;
			offset.left += element.offsetLeft;
			element = element.offsetParent;
		}
		return offset;
	},
	
	/**
	 * Sets the position of the given element relative to the reference one.
	 * @param element the element to be positioned
	 * @param reference the reference element for position
	 * @param positioning can have a combination of one or two of the following values: 
	 * above, below, left, right,
	 * center (of the window, not the reference element).
	 * @return new position of the element
	 *
	 * Good luck understanding this, brave soul. 
	 */
	setPositionRelativeTo : function (element, reference, positioning) {
		var $element = $(element);
		
		// TODO move the element in DOM if relative positioning
		
		// position the target if it has position absolute, but relative to the invoker
		if (window.getComputedStyle(element).position == "absolute") {
			var $reference = $(reference);
			var lca = NodeUtils.getLowestCommonAncestor(reference, element, "offsetParent");
			var position = WindowUtils.getOffsetRelativeTo(reference, lca);
			
			element.style.minWidth = (reference.offsetWidth - 2) + "px";
						
			if (!positioning) {
				positioning = [POSITIONING.CENTER];
			} else if (positioning.split) {
				positioning = positioning.split(SEPARATOR);
			}
			if (positioning.indexOf(POSITIONING.BELLOW) >= 0) {
				position.top += $reference.height();
			}
			if (positioning.indexOf(POSITIONING.ABOVE) >= 0) {
				position.top -= $element.outerHeight(true);						
			}
			if (positioning.indexOf(POSITIONING.RIGHT) >= 0) {
				position.left += $reference.outerWidth() - $element.outerWidth();
			}
			if (positioning.indexOf(POSITIONING.CENTER) >= 0) {
				var $win = $(window);
				position.top = Math.max(0, (($(lca).outerHeight() - $element.outerHeight()) / 2) + $win.scrollTop());
				position.left = Math.max(0, (($(lca).outerWidth() - $element.outerWidth()) / 2) + $win.scrollLeft());
			}
			
			// check overlay position relative to viewport
			if ($element.hasClass('overlay') && $("#content").length) {
				var box = {
						left: $("#content").offset().left,
						right: $("#content").offset().left + $("#content").width(),
						width: $("#content").width()
				};
				if (box.width < $element.width()) {
					$element.width(box.width);
				}
				if (box.left > position.left) {
					position.left = box.left;
				} else if (box.right < position.left + $element.outerWidth()) {
					position.left = position.left - (position.left + $element.outerWidth() - box.right);
				}
			}
			
			element.style.top = position.top + "px";
			element.style.left = position.left + "px";
			
			// set arrow position
			if ($element.hasClass('overlay') && $("#content").length) {
				var $arrow = $element.find("SPAN.arrow");
				if ($arrow.length) {
					var offset = $arrow.offset();
					offset.left = position.left + $reference.offset().left - position.left + $reference.width() / 2 - $arrow.width() / 2;
					$arrow.offset(offset);
				}
			}
			
			return position;
		}
	}
	};
	
	return WindowUtils;
});

//define JSON.parse
if (typeof JSON == "undefined") {
	window.JSON = {parse: function(text) {return eval ("(" + text + ")");}};
}
;
/**
 * A module that augments elements (by default A with CSS class expanded or
 * collapsed) and make them a trigger for other element to expand/collapse. The
 * element that triggers this is called invoker and the one that
 * expands/collapses is called target.
 *
 * Notice: work in progress
 */
define("Expander", ["JSUtils", "WindowUtils", "NodeUtils", "jquery"], function (JSUtils, WindowUtils, NodeUtils, $) {
	"use strict"
	var EXPANDED_CLASS = "expanded";
	var COLLAPSED_CLASS = "collapsed";
	var CLASSES = [EXPANDED_CLASS, COLLAPSED_CLASS];

	var P_AUTO = "auto",
		P_ABOVE = "above", P_BELLOW = "bellow", P_LEFT = "left", P_RIGHT = "right",
		P_CENTER = "center", P_SCROLL = "scroll", P_FIXED = "fixed";

	var SEPARATOR = ",";

	var ATTR_POSITION = "data-position";
	var ATTR_SCROLL_TO = "data-scroll-to";

	var ATTR_EXPAND_ON = "data-invoke-on";
	var EXPAND_ON_CLICK = "click";
	var EXPAND_ON_HOVER = "hover";
	var EXPAND_NONE = "none";
	
	var ATTR_COLLAPSE_ON = "data-close-on";
	var COLLAPSE_ON_CLICK = EXPAND_ON_CLICK;
	var COLLAPSE_ON_BLUR = "click-outside";
	var COLLAPSE_ON_MOUSE_OUT = "mouse-out";

	var EVENT_COLLAPSE = "collapse";
	var EVENT_EXPAND = "expand";
	

	/**
	 * If we have to scroll anything under this (in pixels) we won't scroll
	 * anymore.
	 */
	var SCROLL_TOLERANCE = 10;
	/** The timeout after a popup is hidden in milliseconds. */
	var DEFAULT_TIMEOUT = 1000;

	/**
	 * Creates a new expander.
	 * @param invoker the invoker element
	 * @param target the target element; if not specified tries to get it from the invoker element using
	 * the href attribute for A and data-href for others to get the target element id.
	 */
	var Expander = function(invoker, targets) {
		this.invoker = invoker;
		this.invoker.expander = this;
		this.$invoker = $(invoker);
		var $invoker = this.$invoker;
		this.hideTimeout = null;

		// if no target specified, then create it
		// if still not possible, return, we have an invalid expander
		if (this.getTargets(targets) == null) {
			return;
		}
		
		bindInvokers(this);

		// set initial state
		var initialState = false;
		if (invoker.tagName == "OPTION") {
			initialState = invoker.selected;
		} else if (invoker.tagName == "INPUT" && (invoker.type == "radio" || invoker.type == "checkbox")) {
			initialState = invoker.checked;
		} else {
			initialState = this.isExpanded();
		}
		this.setExpanded(initialState, 0, true);
	};

	
	
	var INVOKER = 0;
	var TARGET = 1;
	var EXPANDER_EVENT_TARGET = {0: function(expander) { return expander.$invoker;},
			1: function(expander) { return expander.getTargets();}};
	var EXPANDER_TOGGLE_STATE = function(expander) { return !expander.isExpanded();};
	var EXPANDER_INVOKER_VALUE = function(expander) { return expander.$invoker.val();};

	var DEFAULT_ACTION = {
			type: INVOKER,
			state: true,
			delay: 0,
			handler: function (event) {
				var action = this;
				var element = event.target;
				if (element.expander)
					element.expander.setExpanded(action.state, action.delay);
				else if (element.expanders)
					element.expanders.forEach(function(expander) {
						expander.setExpanded(action.state, action.delay);
					});
				if (event.type == "click") {
					event.preventDefault();
				}
			}
		};
		
	var ACTIONS = [
        /*
	    { 
	        // if the action is applied on the invoker or targets, if not specified INVOKER
	    	type: INVOKER|TARGET
	    	
	    	// what will be the new state of the expander; if function will be calculated each time; if not specified true
	    	state: true|false|<function>,
			
			// the event can be applied to something else than invoker or targets, if you specify this function or selector
			eventTarget: <function>, 
			
			// the event type
			event: "",
			
			// if the state is modified with delay
			delay: <integer>|<function>
			
			// all the functions above receive as first argument the expander
	    },
	    */
	    {
	    	state: true,
	    	event: "mouseenter",
	    	defaultFor: "[data-close-on*='mouse-out']"
	    },
	    {
	    	state: false,
	    	event: "mouseleave",
	    	delay: -1,
	    	defaultFor: "[data-invoke-on*='hover']"
	    },
	    {
	    	state: true,
	    	event: "focus",
	    	defaultFor: "INPUT[type='text'], TEXTAREA"
	    },
	    {
	    	state: true,
	    	event: "blur",
	    	defaultFor: "INPUT[type='text'], TEXTAREA"
	    },
	    {
	    	state: EXPANDER_INVOKER_VALUE,
	    	eventTarget: function(expander) { return expander.$invoker.closest("SELECT")},
	    	event: "change",
	    	handler: function (event) {
	    		$(event.target).find("OPTION.expanded, OPTION.collapsed").each(function(index, option) {
	    			if (option.expander) 
	    				option.expander.setExpanded(option.selected);
	    		});
	    	},
	    	defaultFor: "OPTION"
	    },
	    {
	    	state: EXPANDER_INVOKER_VALUE,
	    	event: "change",
	    	defaultFor: "INPUT[type='radio'], INPUT[type='checkbox']"
	    },
	    {
	    	state: EXPANDER_TOGGLE_STATE,
	    	event: "click",
	    	defaultFor: "*"
	    },
	    {
	    	type: TARGET,
	    	state: true,
	    	event: "mouseenter",
	    	defaultFor: "[data-close-on*='mouse-out']"
	    },
	    {
	    	type: TARGET,
	    	state: false,
	    	event: "mouseleave",
	    	delay: -1,
	    	defaultFor: "[data-invoke-on*='hover']"
	    }
        ];

    var EVENT_ALIASES = { "hover": "mouseenter", "select": "change", "mouse-out": "mouseleave"};
	
	function bindInvokers(expander, element, type, state) {
		if (!element) {
			bindInvokers(expander, expander.invoker, INVOKER, true);
			bindInvokers(expander, expander.invoker, INVOKER, false);
			expander.getTargets().each(function(index, target) {
				bindInvokers(expander, target, TARGET, true);
				bindInvokers(expander, target, TARGET, false);				
			});
		}
		
		for (var i = 0; i < ACTIONS.length; i++) {
			// get the action by combining with default values
			var action = $.extend({}, DEFAULT_ACTION, {eventTarget: EXPANDER_EVENT_TARGET[type]}, ACTIONS[i]);
			
			// if the type or state does not correspond move to the next
			if (type != action.type || (!$.isFunction(action.state) && state != action.state))
				continue;
			
			var events = element.getAttribute(state ? "data-invoke-on" : "data-close-on");
			if (events == null && action.defaultFor && $(element).is(action.defaultFor))
				events = action.event;
			if (events == null)
				continue;
			events = events.split(",");
			for (var j = 0; j < events.length; j++) {
				if (EVENT_ALIASES[events[j]])
					events[j] = EVENT_ALIASES[events[j]];
			}
			if (events.indexOf(action.event) >= 0) {
				// bind the action
				var $eventTarget = action.eventTarget.call(expander, expander);
				$eventTarget.off(action.event + ".expander");
				$eventTarget.on(action.event + ".expander", $.proxy(action.handler, action));
			}
		}
	}

	
	/** Dummy event handler which prevents default behavior. */
	var ignoreEvent = function(event) {
		event.preventDefault();
		event.stopPropagation();
		return false;
	};
		
	function onDocumentClick(event) {
		// collapses expanders with absolutely positioned targets
		// unless the click was inside such an element
		var el = $(event.target).closest(".expanded");
		if (el.length > 0)
			return;
		$(".expanded").each(function(index, expEl) {
			if (window.getComputedStyle(expEl).position == "absolute") {
				if (expEl.expander) 
					expEl.expander.setExpanded(false);
			}
		});
	}

	
	Expander.prototype._initTargets = function($targets) {
		var expander = this;

		$targets.each(function(index, target) {
			var $target = $(target);
			if (!target.expanders) {
				target.expanders = [];
			}
			target.expanders.push(expander);

			// move the target in the DOM hierarchy if necessary
			var lca = NodeUtils.getLowestCommonAncestor(target, expander.invoker);
			if ((!target.getAttribute(ATTR_POSITION) || target.getAttribute(ATTR_POSITION) == "after")
					// the target is not a descendant of the invoker
					&& (lca != target)
					// the invoker is not a descendant of the target
					&& (lca != expander.invoker)
					// target and invoker are in the same DOM element
					&& (expander.invoker.parentNode != target.parentNode)
					// and target is not an overlay
					&& !$target.hasClass("overlay")
					) {
				// put the target below the same node as the invoker
				expander.$invoker.after(target);
			}
			if ($target.hasClass("overlay")) {
				$(document.body).append($target);
			}

			// retain the initial height of the target
			if (target.offsetHeight > 0) {
				if (!expander.targetExpandedHeight) {
					expander.targetExpandedHeight = {};
				}
				expander.targetExpandedHeight[target] = target.offsetHeight;
			}
		});
	};

	/** @return the first target from the list of targets. */
	Expander.prototype.getTarget = function() {
		var t = this.getTargets();
		return t ? t[0] : null;
	};

	/** @return the target elements associated with this expander as a jQuery object. */
	Expander.prototype.getTargets = function(targetsAttr) {
		if (targetsAttr) {
			this.targetsAttrSpecified = true;
		} else {
			if (this.targetsAttrSpecified) {
				targetsAttr = this.targetsAttr;
			} else {
				targetsAttr = this.$invoker.attr("href");
				if (targetsAttr) {
					targetsAttr = targetsAttr.substring(targetsAttr.lastIndexOf('#'));
				}
				if (!targetsAttr) {
					targetsAttr = this.$invoker.attr("data-href")
				}
			}
		}
		if (targetsAttr != this.targetsAttr) {
			this.targetsAttr = targetsAttr;
			this.$targets = $(targetsAttr);
			this._initTargets(this.$targets);
		}

		return this.$targets;
	};

	/**
	 * @return true if the target element is expanded, false otherwise
	 */
	Expander.prototype.isExpanded = function() {
		return this.$invoker.hasClass(EXPANDED_CLASS);
	};

	Expander.prototype.scrollTo = function(target) {
		if (this.invoker.getAttribute(ATTR_SCROLL_TO) == "false") {
			return;
		}

		if (!target) {
			target = (this.isExpanded() ? this.$targets[0] : this.invoker);
		}

		// scroll to this expand link
		var targetOffset = WindowUtils.getOffsetRelativeTo(target),
				invokerOffset = WindowUtils.getOffsetRelativeTo(this.invoker);
		var currentScroll = {top: $(window).scrollTop()};
		// we will scroll to the expanded element only if it is not fully
		// visible
		if ((this.targetExpandedHeight && this.targetExpandedHeight[target] == 0)
				|| (targetOffset.top + this.targetExpandedHeight > $(window).height() + currentScroll.top)) {
			// if the link is near to the expanded element scroll to link
			// instead
			if (invokerOffset.top + this.invoker.offsetHeight - targetOffset.top < 20) {
				if (Math.abs(currentScroll.top - invokerOffset.top) > SCROLL_TOLERANCE) {
					WindowUtils.scrollSmooth(invokerOffset);
				}
			} else {
				if (Math.abs(currentScroll.top - targetOffset.top) > SCROLL_TOLERANCE) {
					WindowUtils.scrollSmooth(targetOffset);
				}
			}
		}
	}

	/** Adds all expanders in the same group as the given expander or DOM element to the given array
	 * and returns it. 
	 * @param expanderGroup the array to which the related expanders are added. If null, a new element is created. */
	var getExpanderGroup = function(expander) {
		// was it calculated before?
		if (expander.group && expander.group.length > 0)
			return expander.group;
		
		var group = [];
		var elements = [];
		elements.push(expander.invoker);
		expander.getTargets().each(function(index, target) {elements.push(target);});
		$(elements).each(function(index, element) {
			var groupName = element.getAttribute("data-group");
			var $groupElements;
			if (groupName != null && groupName != "") {
				$groupElements = $("*[data-group='" + groupName + "']");
			} else if (element.tagName == "INPUT" && element.getAttribute("type") == "radio" && element.name) {
				$groupElements = $("INPUT[type='radio'][name='" + element.name + "']");
			} else if (element.tagName == "OPTION") {
				$groupElements = $(element).closest("SELECT").find("OPTION.expanded, OPTION.collapsed");
			} else if (element.tagName == "A" && element.parentNode.tagName == "LI") {
				// if the invoker is an A tag right inside an UL list
				var $parentList = $(element).closest("UL");
				if (!$parentList.data("multiple")) {
					// get the links on the same level
					$groupElements = $parentList.find("LI > A");
				}
			}
			
			if ($groupElements) {
				$groupElements.each(function(idx, el) {
					if (el.expander && el.expander != expander && group.indexOf(el.expander) < 0) {
						group.push(el.expander);
					}
				});
			}
		});
		
		expander.group = group;
		
		return group;
	}
	
	/**
	 * @param expanded true if the target elements should be expanded, false otherwise
	 * @param ms the number of milliseconds to expand/collapse after
	 * @param force if true the expander is expanded even if it has the same state already - useful for reset
	 */
	Expander.prototype.setExpanded = function(expanded, timeoutInMs, force) {
		// clear the timeout (most probably for collapsing)
		if (this.timeout) {
			clearTimeout(this.timeout);
		}

		// if it is disabled or already in the required state, then do nothing
		if (!this.isEnabled() || (force != true && this.isExpanded() == expanded)) {
			return;
		}

		var expander = this;
		if ($.isFunction(expanded))
			expanded = expanded.call(expander, expander);
	
		if (timeoutInMs) {
			if (timeoutInMs < 0)
				timeoutInMs = DEFAULT_TIMEOUT;
			expander.timeout = setTimeout(function() {
				expander.timeout = null;
				expander.setExpanded(expanded);
			}, timeoutInMs);
			return;
		}		
		
		var invoker = this.invoker;
		var $targets = this.getTargets();

		if (expanded) {
			getExpanderGroup(this).forEach(function(expander) { expander.setExpanded(false);});
		} else {
			$targets.each(function(index, target) {
				if (target.offsetHeight > 0) {
					if (!expander.targetExpandedHeight) {
						expander.targetExpandedHeight = {};
					}
					expander.targetExpandedHeight[target] = target.offsetHeight;
				}
				// if the target was positioned relatively then reset it
				if (window.getComputedStyle(target).position == "relative" && !expanded) {
					target.style.top = "0px";
					target.style.left = "0px";
				}
			});
			$(document).unbind('click.expanderclickhandler');
			if (WindowUtils.isTouchDevice()) {
				try {
					$(document).unbind('touchstart.expanderclickhandler');
				} catch (e) {}
			}
		}

		// set the CSS class for the invoker and the targets
		if (expanded) {
			this.$invoker.removeClass(COLLAPSED_CLASS);
			this.$invoker.addClass(EXPANDED_CLASS);
			$targets.removeClass(COLLAPSED_CLASS);
			$targets.each(function(index, target) {
				var $target = $(target);
				if (!$target.hasClass(EXPANDED_CLASS)) {
					$target.addClass(EXPANDED_CLASS);

					// move the targets into the right place
					var positioning = target.getAttribute(ATTR_POSITION);
					if (!positioning) {
						positioning = ($target.hasClass("overlay") ? [P_CENTER] : [P_BELLOW, P_LEFT]);
					}
					WindowUtils.setPositionRelativeTo(target, invoker, positioning);
				}
			});

			// scroll to the first expanded target
			this.scrollTo();
		} else {
			this.$invoker.removeClass(EXPANDED_CLASS);
			this.$invoker.addClass(COLLAPSED_CLASS);
			$targets.removeClass(EXPANDED_CLASS);
			$targets.addClass(COLLAPSED_CLASS);
		}

		// trigger custom expand/collapse events
		var customExpandEvent = expanded ? "expand" : "collapse";
		this.$invoker.trigger(customExpandEvent);
		$targets.trigger(customExpandEvent);

		// if the targets are associated to different expanders, update the
		// state on those ones too
		$targets.each(function (index, target) {
			if (!target.expanders)
				return;
			target.expanders.forEach(function(expnd) {
				if (expnd != expander && expnd.isExpanded() != expanded) {
					expnd.setExpanded(expanded);
				}
			});
		});

		// the try-catch is for using zepto which does not support custom events
		try {
			if (!$.transitionsEnabled) {
				$(this).trigger("transitionend");
			}
		} catch(e) {}
	};

	/** If the target element is expanded, it collapses it. Otherwise it will expand. */
	Expander.prototype.toggle = function() {
		this.setExpanded(!this.isExpanded());
	};

	/** Collapses the elements. */
	Expander.prototype.collapse = function() {
		this.setExpanded(false);
	};

	/**
	 * Return true is expander can be activated.
	 */
	Expander.prototype.isEnabled = function() {
		return this.invoker.getAttribute("disabled") != "true";
	};

	/** Initializes all the A elements in a document if they have the expanded/collapsed class.
	 * @param doc the document; by default the current document.
	 */
	Expander.initAll = function() {
		$(document).off("click.expanders", onDocumentClick);
		$(document).on("click.expanders", onDocumentClick);
		
		// add to overlays the close button
		$(".overlay[id]").each(function (index, element) {
			$(element).prepend("<a href='#" + element.id + "' class='collapsed close'>X</a>");
		});

		// initialize expanders
		$("." + EXPANDED_CLASS + "[href], ." + COLLAPSED_CLASS + "[href], ."
				+ EXPANDED_CLASS + "[data-href], ." + COLLAPSED_CLASS + "[data-href]")
				.each(function(index, link) {
			if (!link.expander) {
				new Expander(link);
			}
		});
	};

	return Expander;

});

/**
 * A selectable list is a list of which items can be selected. A selected item is an item with the CSS class 
 * <code>selected</code>. 
 * A list can be exclusive (only one item selected) or not (multiple items can be selected). 
 * If it is not exclusive, clicking on an item will toggle this functionality. 
 * This behavior can be changed through the <code>data-multiple</code> attribute (if true, the list is non-exclusive). 
 * By default, a selectable list is exclusive.
 */
define("SelList", ["jquery"], function($) {
	function onClickList(event) {
		var $li = $(event.target).closest("LI");
		if (!($li.length > 0)) {
			return;
		}
		var li = $li[0];
		var $list = $li.parent();
		if ($list.attr("data-multiple") == "true") {
			$li.toggleClass(SelList.options.selectedClass);
		} else {
			$li.addClass(SelList.options.selectedClass);
			$list.find("LI").each(function (index, item) {
				if (item != li) {
					$(item).removeClass(SelList.options.selectedClass);
				}
			});
		}
	}
	
	var SelList = function(elem) {
		elem.selList = this;
		this.element = elem;
		$(elem).click(onClickList);
	};

	/**
	 * It will enable the selectable list behavior to all the lists (UL) augmented with the CSS class 
	 * {@code selectable}.
	 * @param doc the document on which elements will act on. If missing, then the active document is used.
	 */
	SelList.initAll = function(selector) {
		$(selector || "UL.selectable").each(function (index) {
			if (!this.selList) {
				new SelList(this);
			}
		});
	};
	
	SelList.options = {
		selectedClass: "selected"
	};
	
	return SelList;
});

define("DocUtils", ["jquery", "JSUtils"], function($, JSUtils) { return {
	/**
	 * @param doc an element or document in which we will generate an unique id
	 * @param prefix the prefix used for the id, if not specified by default is {@code _}
	 * @return a unique id in the given document
	 */
	generateUniqueId : function(doc, prefix) {
		// if prefix is not specified, but doc is a string
		if (prefix == null && doc && doc.substring) {
			doc = null;
			prefix = doc;
		}
		
		if (doc == null) {
			// if doc is not specified, then use the document
			doc = document;
		} else  if (doc.ownerDocument) {
			// if doc is actually an element use the containing document instead
			doc = doc.ownerDocument;
		}
		
		if (prefix == null) {
			prefix = "_";
		}
		
		// generate a new id while we found an element with that id
		var id;
		do {
			id = prefix + JSUtils.randomInt(10000, 99999);
		} while (doc.getElementById(id));
		
		return id;
	},
	
	/**
	 * Function for including a JS script into the page
	 * @param src script inline code when "inline" parameter is true,
	 * 	 otherwise the script URL should be provided
	 * @param inline flag specifing
	 * @return script node 
	 */
	includeScript : function(src, inline) {
		// don't use jQuery/Zepto - they have different bugs when inserting scripts
		// scripts are not getting executed or "onLoad" script event is not triggered
		var script = document.createElement('script');
		script.setAttribute('type', 'text/javascript');
		if (inline) {
			if (script.innerHTML) {
				script.innerHTML = src;
			} else {
				script.text = src;
			}
		} else {
			script.setAttribute('src', src);
			script.setAttribute('defer', "defer");
		}
		document.getElementsByTagName('head')[0].appendChild(script);
		return script;
	}
};});

if (!document.head) {
	// IE7 and IE8 fix
	document.head = document.getElementsByTagName('head')[0];
}

if (!window.getComputedStyle) {
	window.getComputedStyle = function(element) {
		if (typeof element.currentStyle != 'undefined')
			return element.currentStyle;
		if (typeof element.runtimeStyle != 'undefined')
			return element.runtimeStyle;
	};
}
;
/** Augments a SELECT element and associates a UL with a LI for each option. 
 * The UL is expanded/collapsed using an A tag.
 * The custom drop-down is kept in sync with the augmented SELECT element.
 * This allows greater level of customization and in-line selection on mobile browsers (as opposed to overlay)
 */
define("CustomSelect", ["jquery", "DocUtils", "NodeUtils", "Expander", "SelList", "HPUtils"], 
		function($, DocUtils, NodeUtils, Expander, SelList, HPUtils) {

	/** Called when an item from the list is chosen. */
	var onOptionClick = function(event) {
		var customSelect = $(event.target).closest("." + CustomSelect.options.selectClassName);
		if (customSelect.length <= 0) {
			return;
		}
		customSelect = customSelect[0].customSelect;
		
		// select the option associated with the clicked list item
		var $select = $(customSelect.select);
		var newValue = $(event.target).closest("LI").find("A").attr("rel");
		if (newValue != $select.val()) {
			$select.val(newValue);
			$select.trigger("change");
			
			customSelect.update();
		}
		
		// collapse the list
		customSelect.expander.setExpanded(false);
		
		event.preventDefault();
		return false;
	};
	
	/** Called when the inline dropdown loses focus in order to hide the options */
//	var onContainerBlur = function(event) {
//		try {
//			this.expander.setExpanded(false);
//		} catch(e) {console.log(e);}
//	};
	
	var onChangeSelect = function(event) {
		event.target.customSelect.update();
	};

	/** Creates a custom layout drop-down.
	 * @param select the SELECT element that will be replaced with the custom drop-down. Mandatory. 
	 */
	var CustomSelect = function(select) {
		if (select.tagName == "SELECT") {
			this.select = select;
			this.select.customSelect = this;
			createListFromSelect.apply(this);
			this.select.style.display = "none";
		} else {
			this.container = select;
		}
		this.container.customSelect = this;
		// add the events
		$(this.list).click(onOptionClick);
				
		if (!this.expander) {
			this.expander = new Expander($(this.container).children("A:first"));
		}
		this.expander.customSelect = this;
		
		$(select).on("change", onChangeSelect);
		
		this.update();
		new SelList(this.list);
	};

	/** It will create a DIV representing the custom drop-down and it will populate it with all the options from the 
	 * native drop-down. 
	 */
	var createListFromSelect = function() {
		var id = DocUtils.generateUniqueId(this.select);
		
		this.container = this.select.ownerDocument.createElement("DIV");
		this.container.className = CustomSelect.options.selectClassName + " " + this.select.className;
		this.container.innerHTML = "<a class='select collapsed' href='#" + id + "'></a>"
				+ "<ul id='" + id + "' class='links selectable'></ul>";
		this.container.customSelect = this;
		$(this.select).after(this.container);
		
		this.expander = new Expander(this.container.firstChild);
		this.list = this.container.lastChild;
		
		// add the options
		populateListFromSelect.apply(this);		
	};
	
	/** Called initially to populate the custom dropdown from the native one. */
	var populateListFromSelect = function() {
		var list = this.list;
		list.innerHTML = "";
		// add a new LI for each OPTION
		for (var i = 0; i < this.select.options.length; i++) {
			var o = this.select.options[i];
			var val = $(o).val(); 
			var li = this.select.ownerDocument.createElement("LI");
			li.innerHTML = "<a href='" + val + "' rel='" + val + "'>" + o.text + "</a>";
			list.appendChild(li);
		}
	};
	
	/** Updates the link according to the selected item. */
	CustomSelect.prototype.update = function() {
		var s = this.select;
		var expanderInvoker = this.expander.invoker;
		var $expanderInvoker = $(expanderInvoker);
		$(this.list).find("LI").removeClass(CustomSelect.options.selectedClassName);
		if (s) {
			if (s.selectedIndex >= 0) {
				$expanderInvoker.html(s.options[s.selectedIndex].text);
				$expanderInvoker.addClass(CustomSelect.options.selectedClassName);
				$(this.list).find("LI:nth-child(" + (s.selectedIndex + 1) + ")").addClass(CustomSelect.options.selectedClassName);
			} else {
				$expanderInvoker.html(s.getAttribute("placeholder") || s.getAttribute("data-placeholder") 
						|| CustomSelect.options.placeholder);
				$expanderInvoker.removeClass(CustomSelect.options.selectedClassName);
			}
		}
	};
	
	/** Augments all the SELECT tags in the page that have the 'inline' CSS class. */
	CustomSelect.initAll = function(selector) {
		$(selector || "SELECT.inline, SELECT.custom").each(function(index) {
			if (!this.customSelect) {
				new CustomSelect(this);
			}
		});
	};
	
	CustomSelect.options = {
		// the default text displayed if no option is selected, 
		// can be overwritten by placeholder or data-placeholder attribute
		placeholder: "...",
		// the class name added to the custom drop down element
		selectClassName: "select",
		// the class name to which a custom drop down is annotated if it has at least one value selected
		selectedClassName: "selected"
	};

	return CustomSelect;
});


/** Augments a SELECT element and associates a UL with a LI for each option. 
 * The UL is expanded/collapsed using an A tag.
 * The custom drop-down is kept in sync with the augmented SELECT element.
 * This allows greater level of customization and in-line selection on mobile browsers (as opposed to overlay)
 */
define("CustomInputRadio", ["jquery", "HPUtils"], 
		function($, HPUtils) {

	var EXPAND_CLASSES_REGEXP = /expanded|collapsed/g;
	
	/** Creates a custom layout drop-down.
	 * @param select the SELECT element that will be replaced with the custom drop-down. Mandatory. 
	 */
	var CustomInputRadio = function(input) {
		input.customInputRadio = this;		
		this.input = input;
		this.$input = $(input);
		this.$input.after("<span class='" + this.$input.attr("type") + (this.input.checked ? " checked" : "") 
				+ " " + this.input.className.replace(EXPAND_CLASSES_REGEXP, "") + "'></span>");
		this.$customElement = this.$input.next();
		this.customElement = this.$customElement[0];
		this.customElement.customInputRadio = this;
		HPUtils.hide(this.$input);
	};
	
	CustomInputRadio.CLASS_CHECKED = "checked";
	CustomInputRadio.CLASS_DISABLED = "disabled";
	
	CustomInputRadio.prototype.isDisabled = function() {
		return this.input.getAttribute("disabled") || this.$customElement.hasClass(CustomInputRadio.CLASS_DISABLED);
	};
	
	CustomInputRadio.prototype.update = function(doNotUpdateRadioGroup) {
		var checked = this.input.checked;
		if (checked == this.$customElement.hasClass(CustomInputRadio.CLASS_CHECKED)) {
			return;
		}
		if (checked) {
			this.$customElement.addClass(CustomInputRadio.CLASS_CHECKED);
		} else {
			this.$customElement.removeClass(CustomInputRadio.CLASS_CHECKED);			
		}
		if (!doNotUpdateRadioGroup) {
			this.updateRadioGroup();
		}
	};
	
	CustomInputRadio.prototype.updateRadioGroup = function() {
		if (this.input.type == "radio") {
			var doNotUpdateInput = this.input;
			$("INPUT[name='" + this.input.name + "']").each(function(index, input) {
				if (input != doNotUpdateInput) {
					input.customInputRadio.update(true);
				}
			});
		}
	};
	
	CustomInputRadio.prototype.toggle = function() {
		if (this.isDisabled()) {
			return;
		}
		var checked = !this.input.checked;
		this.input.checked = checked;
		this.$input.trigger("change");
	};
	
	CustomInputRadio.documentEventsAdded = false;

	CustomInputRadio.addDocumentEvents = function() {
		if (CustomInputRadio.documentEventsAdded) {
			return;
		}
		CustomInputRadio.documentEventsAdded = true;
		$(document).on("click touchstart", "SPAN.radio, SPAN.checkbox", function(e) {
			e.stopPropagation();
			e.preventDefault();
			var custom = e.target.customInputRadio;
			// if the radio button is already selected do nothing
			if (custom.input.type != "radio" || !custom.input.checked)
				custom.toggle();
			return false;
		});
		$(document).on("change", "INPUT[type=checkbox], INPUT[type=radio]", function(e) {
			e.target.customInputRadio.update();
		});
	};
	
	/** Augments all the SELECT tags in the page that have the 'inline' CSS class. */
	CustomInputRadio.initAll = function(selector) {
		CustomInputRadio.addDocumentEvents();
		$(selector || "INPUT[type='checkbox'], INPUT[type='radio']").each(function(index, input) {
			if (!input.customInputRadio) {
				new CustomInputRadio(input);
			}
		});
	};

	return CustomInputRadio;
});


define("Template", ["jquery"], function($) {
	function forEach(array, f) {
		if ($.isArray(array)) {
			return $.each(array, f);
		} else {
			var i = 0;
			while (array[i] != null) {
				f(i, array[i]);
			}
		}
	}
	
    // evaluate each element of the array
    function eachEvalResolver(object, property, context, template) {
    	if (object == null)
    		return null;
    	
		// if the property marks an evaluation on each element
    	if (property == "__evalEach__") {
    		if (object.___evalEach__) {
    			forEach(object, function (i) { 
//    			for (var i = 0; i < object.length; i++) {
    				object[i] = eachEvalResolver(object[i], property, context, template);
//    			}
    			});
    		} else {
				object = $.extend(true, [], object);
    			object.___evalEach__ = true;
    		}
    		return object;
    	}
    	
		if (object.___evalEach__) {
			forEach(object, function (i) { 
//    		for (var i = 0; i < object.length; i++) {
    			if (object[i].___evalEach__ && $.isArray(object[i]))
    				object[i] = eachEvalResolver(object[i], property, context, template);
    			else
    				object[i] = template.evalObjectProperty(object[i], property, context);
//    		}
			});
    		return object;
    	}
		
    	return null;
    }

	
	var resolvers = [
 	    // this
	    function (object, property, context) {
	    	return (!object && property == "this" ? context : null);
	    },
	                 
	    // initial objects
	    function (object, property, context) {
	    	if (object)
	    		return null;
	    	return context[property];
	    },
	                 
	    // property
	    function (object, property) {
	    	return (object ? object[property] : null);
	    },
	    
	    // attribute
	    function (object, property) {
	    	return (object && $.isFunction(object.getAttribute) ? object.getAttribute(property) : null)
	    },
	    
	    // getter
	    function (object, property) {
	    	if (!object)
	    		return null;
	    	var getterName = "get" + property.charAt(0).toUpperCase() + property.substring(1);
			if ($.isFunction(object[getterName])) {
				return context[getterName].call(context);
			}
	    },
	    
	    // document id
	    function (object, property) {
	    	if (!object) {
	    		object = document;
	    	}
	    	if (object.ownerDocument) {
	    		object = object.ownerDocument;
	    	}
	    	if ($.isFunction(object.getElementById))
	    		return object.getElementById(property);
	    	return null;
	    },
	    
	    // jquery selector
	    function (object, property) {
	    	var $obj = null;
	    	if (object) {
	    		try {
	    			$obj = $(object);
	    		} catch (e) {
	    			// catch zepto "DOM exception 12 - invalid string specified" when applying $() on objects like
	    			// [<option>ananas</option>,<option>apple</option>,<option>orange</option>]
	    		}
	    	}
	    	var value = ($obj ? $obj.find(property) : $(property));
	    	return value.length > 0 ? value : null;
	    },
	    
	    eachEvalResolver,
	    	    
	    // true/false constants
	    function (object, property) {
	    	if (object)
	    		return null;
	    	switch(property) {
	    		case "true":
	    			return true;
	    		case "false":
	    			return false;
	    		default:
	    			return null;
	    	}
	    }
	    
	]; 
	
	var PatternCompiler = function(replacements) {
		this.replacements = replacements;
	};
	
	PatternCompiler.prototype.translate = function(template) {
		var code = template.code;
		for (var i = 0; i < this.replacements.length; i++) {
			code = code.replace(this.replacements[i].token, this.replacements[i].value);
			if (template.options.debug && window.console) {
				console.log("Translated code after replacement " + i 
						+ " [" + this.replacements[i].token + "]:\n" + code);
			}
		}
		return code;
	};
	
	var jspCompiler = new PatternCompiler([
	        // replace ' with \' outside scriptlets
	        {token: /(^|%>)((?:[^<]|<(?!%))+)(<%|$)/g, value: function(match, prefix, s, suffix, offset, string) {
	        		return prefix + s.replace("'", "\\'") + suffix;
	        	}
	        },
	        // prefix code
       	    {token: /^/g, value: "var t=[];t.a=t.push;t.a('"},
       	    // suffix code
       	    {token: /$/g, value: "');return {tokens: t, value: t.join(''), toString: function(){return this.value;}}"},
       	    // expressions
       	    {token: /<%=((?:[^%]|%[^>])+)%>/g, value: "');t.a($1);t.a('"},
       	    // control code
       	    {token: /<%((?:[^%]|%(?!>))+)%>/g, value: "');$1t.a('"},
       	    // remove empty tokens
       	    {token: /t\.a\(''\);/g, value: ""}
   	]);

	function splitObjectPath(expr) {
		var parts = expr.replace(/\[\]/g, "[__evalEach__]").split(/\[|\.|\]/g);
		for (var i = 0; i < parts.length; i++) {
			if (parts[i].length == 0) {  
				parts.splice(i, 1);
				i--;
			} else if (!((parts[i].charAt(0) == '\'' && parts[i].charAt(parts[i].length - 1) == '\'')
					|| (parts[i].charAt(0) == '"' && parts[i].charAt(parts[i].length - 1) == '"'))) {
				parts[i] = '"' + parts[i] + '"';
			}
		}
		return "[" + parts.join(",") + "]";
	}

	var RESERVED_WORDS = ["in", "instanceof", "typeof", "null", "undefined", "true", "false"];

	function createBasicCompiler(tokenChar) {
		var tokenCharRE = tokenChar;
		if (tokenChar == "$") {
			tokenChar += tokenChar;
			tokenCharRE = "\\$";
		}
		var c = new PatternCompiler([

		    // $$ or ${$} -> $
		    {token: new RegExp(tokenCharRE + "{?" + tokenCharRE + "}?", "g"), value: "<%='" + tokenChar + "'%>"},
	
		    // ${for (var in expr)} -> for(var in eval(expr) { 
		    {token: new RegExp(tokenCharRE 
		    		+ "{\\s*for\\s*\\(\\s*([A-Za-z_][A-Za-z0-9_]*)\\s+in\\s+([A-Za-z_][A-Za-z0-9_.-]*)\\s*\\)\\s*}", 
		    		"g"), 
		    	value: function (match, varName, expr, offset, string) {
		    		var exprVarName = "_" + varName + "s";
		    		var indexVarName = exprVarName + "_index";
		    		return "<%"
		    				+ "var " + exprVarName + " = " + Template.options.templateVarName 
		    					+ ".evalObjectPath(" + splitObjectPath(expr) 
		    					+ ", " + Template.options.contextVarName + ");"
		    				+ "var " + indexVarName + "=-1;"
		    				+ "for(var " + varName + " in " + exprVarName + ") {"
			    				+ "if (!" + exprVarName + ".hasOwnProperty(" + varName + ")) continue;"
			    				+ varName + "=" + exprVarName + "[" + varName + "];"
			    				+ indexVarName + "++;"
			    				// add the index
			    				+ "if(typeof " + varName + " == 'string')" 
			    					+ varName + "= {'#index': " + indexVarName + ", value: " + varName 
			    							+ ", toString: function(){return this.value;}};" 
			    				+ Template.options.contextVarName + "['" + varName + "'] = " + varName + ";"
			    			+ "%>"
		    	}
		    },
		    
		    // ${if (condition)} -> if(condition)
		    {token: new RegExp(tokenCharRE + "{\\s*if\\s*\\(([^}]+)\\)\\s*}", "g"), 
		    	value: function(match, condition, offset, string) {
		    	return "<%if(" 
		    			+ condition.replace(/(['"]?[A-Za-z_][A-Za-z0-9_.-]*['"]?)/g, 
		    					function(match2, expr, offset2, string2) {
		    						if (expr.charAt(0) == '"' || expr.charAt(0) == "'" 
		    								|| $.inArray(expr, RESERVED_WORDS) >= 0) {
		    							return expr;
		    						} else {
		    							return Template.options.templateVarName + ".evalObjectPath(" 
		    									+ splitObjectPath(expr) 
		    			    					+ ", " + Template.options.contextVarName + ")";
		    						}
		    					})
		    			+ "){%>";
		    }},
	
		    // ${else} -> }else{
		    {token: new RegExp(tokenCharRE + "{else}", "g"), value: "<%}else{%>"},
		    
		    // ${end} -> }
		    {token: new RegExp(tokenCharRE + "{end}", "g"), value: "<%}%>"},
	
		    // ${var} -> eval(var)
		    {token: new RegExp(tokenCharRE + "{\\s*([^}]+)\\s*}", "g"), 
		    	value: function (match, expr, offset, string) {
		    		return "<%=" + Template.options.templateVarName + ".evalObjectPath(" + splitObjectPath(expr) 
		    				+ ", " + Template.options.contextVarName + ", '" + match.replace("'", "\'") + "')%>";
		    	}
		    }
		]);
		c.replacements = c.replacements.concat(jspCompiler.replacements);
		return c;
	}
	
	/** Creates a new template.
	 * @param pattern the pattern of the new template.
	 */
	var Template = function(code, language, options) {
		options = $.extend({}, Template.options, options);
		this.options = options;
		
		this.code = code;
		// backward compatibility
		if (language == "@") {
			language = "basic";
			options.tokenChar = "@";
		} else if (language == "html") {
			language = "basic";
		}

		// Creates the code for a function that will evaluate the pattern, 
		// basically translates the tokens into JavaScript code
		if (!language)
			language = "basic";
		var compiler = options.compilers[language];
		if (language == "basic" && options.tokenChar != null && options.tokenChar != '$')
			compiler = createBasicCompiler(options.tokenChar);
		if (!compiler)
			compiler = options.compilers.basic;
		var source = compiler.translate(this);
		// IE7, IE8 fix for 'unterminated string' error when tabs or other special spaces are included in source body
		source = source.replace(/\s/g, ' ');
		
		if (options.debug && window.console) {
			console.log("Template function body:\n " + source.replace(";", ";\n", "g"));
			this.source = source;
		}
				
		// Create a function that will evaluate the template - Do not use eval IE8 does not know about it
		this.func = new Function(options.contextVarName, options.templateVarName, source);

		if (options.debug && window.console) {
			console.log("Template function:\n " + this.func);
		}
	};
	
	Template.options = {
		/** The name of the variable/argument holding the context. */
		contextVarName : "ctx",
		/** The name of the variable/argument holding the template. */
		templateVarName : "tmpl",		
		/** If true some debug information are printed in the browser console. */
		debug : false,

		compilers : {
			basic: createBasicCompiler('$')
		},
		
		resolvers : resolvers
	}
		
	Template.prototype.evalObjectProperty = function(object, property, context) {
		var resolvers = this.options.resolvers;
		for (var i = 0; i < resolvers.length; i++) {
			var value = resolvers[i](object, property, context, this);
			// use comparison with null, 0 and false are valid values
			if (value != null)
				return value;
		}
		return null;
	}
	
	Template.prototype.evalObjectPath = function(path, context, defaultValue) {
		var object = null;
		for (var i = 0; i < path.length; i++) {
			object = this.evalObjectProperty(object, path[i], context);
			if (object == null) {
				return defaultValue;
			}
		}
		//return (typeof object == "string" ? object : object.toString());
		return object;
	};
	
	/** Evaluates the template. */
	Template.prototype.render = function(context) {
		return this.func(context, this);
	};
	
	/** Creates a new template and evaluates it against the given context. */
	Template.render = function(pattern, context, language, options) {
		return new Template(pattern, language, options).render(context);
	};
	
	function getLanguage(type) {
		var language = type;
		var idx = type.lastIndexOf('/');
		if (idx >= 0)
			language = type.substring(idx + 1);
		return language;
	}
	
	var templates = {};
	
	Template.registerTemplate = function(templateId, template) {
		templates[templateId] = template;
	};
	
	function getTemplateFromElement($templateElement) {
		var templateElement = $templateElement[0];
		
		// for IE7/8 $(scriptElement).html() does not return the correct value; text property should be used instead
		var code = templateElement.text ? templateElement.text : $templateElement.html();
		
		var cachedTemplate;
		if (templateElement.ext)
			cachedTemplate = templateElement.ext.template;
		
		// is it cached already
		if (!cachedTemplate || cachedTemplate.code != code) {
			// if not, then create it
			cachedTemplate = new Template(code, getLanguage($templateElement.attr("type")),
					{tokenChar: $templateElement.data("token-char")});
			// and cache it
			if (!templateElement.ext)
				templateElement.ext = {};
			templateElement.ext.cachedTemplate = cachedTemplate;
		}
		return cachedTemplate;
	};
	
	/** Given a DOM element returns the template based on its content.
	 * The language of the template is defined by the element attribute 'type' in 
	 * the format 'text/[language]'.
	 * The tokenChar is defined in the data-token-char attribute of the element.
	 * @param templateElement the DOM element containing the template and an optional attribute data-token-char
	 */
	Template.getTemplate = function(templateId) {
		var template = templates[templateId];
		if (template)
			return template;
		
		var $templateId = $(templateId);
		if ($templateId.length > 0)
			return getTemplateFromElement($templateId);

		return null;
	}
		
	/** Given a list of elements returns the templates based on the content of the elements.
	 * The tokenChar is defined in the data-token-char attribute of the element.
	 * @param templateElements a jQuery selector representing the DOM elements containing the templates
	 */
	Template.getTemplates = function(templateIds) {
		var t = [];
		if (templateIds.forEach) {
			templateIds.forEach(function (templateId, index) {
				t[index] = Template.getTemplate(templateId);
			});
		} else {
			$(templateIds).each(function(index, templateId) {
				t[index] = Template.getTemplate(templateId);
			});
		}
		return t;
	};
	
	function populateContent(element, context, additive) {
		var templateElem = element.getAttribute("data-template");
		if (!templateElem)
			return;
		templateElem = element.ownerDocument.getElementById(templateElem);
		if (!templateElem)
			return;
		var template = Template.getTemplate(templateElem);
		
		if (additive == null) {
			additive = element.getAttribute("data-additive");
		}
		
		var content = template.render(context).value;
		if (additive == "true") { 
			$(element).append(content);
		} else {
			$(element).html(content);
		}					
	}
	
	/**
	 * Populates given elements with a template.
	 * @param elements to be populated with the rendered template. The template is contained in an element with
	 * the id specified in the data-template attribute. This attribute is mandatory, otherwise nothing happens.
	 * @param context the context used to render the template
	 * @param additive if the content will be added to the element. If not specified the data-additive attribute
	 * is considered. If the attribute is not specified, false is the default value.
	 */
	Template.populateContent = function(elements, context, additive) {
		// try first if the elements represent a DOM element ID
		var el = document.getElementById(elements);
		if (el) {
			populateContent(el, context, additive);
			return;
		} 		
		
		// if not, then elements is a jquery selector most probably
		$(elements).each(function(index, element) {
			populateContent(element, context, additive);
		});
	};
	
	return Template;
});

define("ContentLoader", ["jquery", "DocUtils", "Template"], 
		function($, DocUtils, Template) {
    
    var AjaxContentLoader = function(url, loadedHandler) {
        this.url = url;
        this.loadedHandler = loadedHandler;
    };
    
    AjaxContentLoader.prototype.cancel = function() {
        if (this.xreq) {
            switch (this.xreq.readyState) {
                case 1:
                case 2:
                case 3:
                    this.xreq.abort();
            }
            this.xreq = null;
        }       
    };
    
    AjaxContentLoader.prototype.load = function() {
        // cancel a previous AJAX call if any
        this.cancel();
        var contentLoader = this;
        
        this.xreq = $.ajax({
        	"url": contentLoader.url,
        	"type": "GET",
        	"headers": {
	        		"Accept": "application/json, text/javascript"
	        	},
        	"dataType": "json",
        	"success": function(data, textStatus, jqXHR) {
	        		if (textStatus == "success") {
	        			contentLoader.loadedHandler.call(contentLoader, data);
	        		}
	        	}
        });
    };

    var JsonpContentLoader = function(url, loadedHandler) {
        this.url = url;
        this.loadedHandler = loadedHandler;
    };
    
    JsonpContentLoader.prototype.cancel = function() {
        // cancel a previous JSONP call if any
        if (this.jsonpScript && this.jsonpScript.parentNode) {
            this.jsonpScript.parentNode.removeChild(this.jsonpScript);
            this.jsonpScript = null;
        }       
    };
    
    JsonpContentLoader.prototype.load = function() {
        this.cancel();
        // replace the tokens in the URL
        var url = this.url;
        // get the callback function name and delete it from the url
        var idx = url.indexOf(':');
        var callback = url.substring(0, idx);
        url = url.substring(idx + 1); 
        // define the callback function
        window[callback] = $.proxy(this.loadedHandler, this);
        //window[callback] = function() {console.log(callback)};
        this.jsonpScript = DocUtils.includeScript(url);
    };
    
    var DomContentLoader = function(doc, id, loadedHandler) {
        if (doc.ownerDocument)
            doc = doc.ownerDocument;
        this.doc = doc;
        this.id = id;
        this.loadedHandler = loadedHandler;
    };
    
    DomContentLoader.prototype.cancel = function() {
    };
    
    DomContentLoader.prototype.load = function() {
        this.loadedHandler.call(this, !this.id || !this.doc.getElementById ? null : this.doc.getElementById(this.id));
        return this;
    };
    
    var ContentLoader = function(source) {
        this.source = source;
    };
    
    ContentLoader.load = function(source, ctx, loadedHandler, template) {
        var handler = function (content) {
            return loadedHandler.call(ctx, template ? template.render(content) : content);
        };
        var loader;
        if (source == null || source.indexOf("id:") == 0) {
            loader = new DomContentLoader(ctx, source.substring(3), handler);
        } else if (source.indexOf("#") == 0) {
            loader = new DomContentLoader(ctx, source.substring(1), handler);
        } else if (source.indexOf("ajax:") == 0) {
            loader = new AjaxContentLoader(source.substring(5), handler);
        } else if (source.indexOf("jsonp:") == 0) {
            loader = new JsonpContentLoader(source.substring(6), handler);
        }               
        loader.source = source;
        loader.load();
        return loader;
    };
    
    ContentLoader.loadElementContent = function(element, source) {
    	if (!source) {
    		source = element.getAttribute("data-source");
    	}
    	ContentLoader.load(source, element, function(content) {
    		Template.populateContent(element, content);
    	});
    };

    return ContentLoader;
});

/** To create an autosuggestion field us new require("AutoSuggest")(element);
 */
define("AutoSuggest", ["jquery", "ContentLoader", "Template", "Expander", "HPUtils"], 
		function($, ContentLoader, Template, Expander, HPUtils) {
	"use strict"
	/** After how much time (in ms) the suggestions list is hidden if the input loses focus. */
	var BLUR_LATENCY = 500;
	/** The default value for the time (in ms) after the suggestions list is (re)populated. */
	var DEFAULT_LOADING_LATENCY = 600;
	/** The default value for the minimum number of characters that needs to be entered to trigger auto-suggestion. */
	var DEFAULT_MIN_CHARS_TO_SUGGEST = 3;
	/** The default value for the maximum number of suggestions displayed, 0 = no limit. */
	var DEFAULT_MAX_SUGGESTIONS = 0;
	
	var SOURCE_ATTRIBUTE = "suggestions";
	var FILTER_ATTRIBUTE = "suggestionfilter";
	var MAPPER_ATTRIBUTE = "suggestionmapper";
	var MAX_SUGGESTIONS_ATTRIBUTE = "maxsuggestions";
	var MIN_CHARS_ATTRIBUTE = "mincharstosuggest";
	
	var SELECTED_CLASS = "selected";
	
	var onKeyupInput = function(event) {
		var autoSuggest = event.target.autoSuggest;
		switch(event.keyCode) {
			case 27: // escape
				if (!autoSuggest.element.expander.isExpanded()) {
					return true;
				}
				autoSuggest.suggestionsLoaded(null);
				event.preventDefault();
				return false;
			case 38: // up arrow
				if (!autoSuggest.element.expander.isExpanded()) {
					return true;
				}
				autoSuggest.moveSelectedSuggestion(-1);
				event.preventDefault();
				return false;
			case 40: // down arrow
				if (!autoSuggest.element.expander.isExpanded()) {
					return true;
				}
				autoSuggest.moveSelectedSuggestion(1);
				event.preventDefault();
				return false;
			case 13: // enter
				// do not autosuggest for jp/ja on ENTER
				if (HPUtils.getLocaleCode().language == "ja") {
					return true;
				}
				if (!autoSuggest.element.expander.isExpanded()) {
					return true;
				}
				autoSuggest.inputSelectedSuggestion();
				autoSuggest.element.expander.setExpanded(false);
				event.preventDefault();
				return false;
			default:
				autoSuggest.loadSuggestions(autoSuggest.getLoadingLatency());
		}
	};
	
	var onBlurInput = function(event) {
		event.target.autoSuggest.prepareCollapse();
	};
	
	var onFocusInput = function(event) {
		event.target.autoSuggest.cancelCollapse();		
		event.target.autoSuggest.loadSuggestions();
	};
	
	var onClickList = function(event) {
		// var listItem = event.target.parentNode;
		var list = event.target.parentNode.parentNode;
		var autoSuggest = list.autoSuggest;
		autoSuggest.cancelCollapse();
		
		var input = autoSuggest.element;

		autoSuggest.setSelectedSuggestion(event.target);
		autoSuggest.inputSelectedSuggestion();
		input.expander.setExpanded(false);
		
		event.preventDefault();
		return false;
	};
	
	var onMouseoverList = function(event) {
		var li = this;
		li.parentNode.autoSuggest.setSelectedSuggestion(li);
	};
	

	
	/**
	 * @param element The input element on which the autosuggest will function.
	 * @param dataSource A ContentLoader string defining the data source from which
	 * the data will be extracted. Equivalent to the data-source attribute.
	 * @param updateCallback Function that will be triggered when a suggestion is selected.
	 * The context of the callback is the autosuggest object.
	 */
	var AutoSuggest = function(element, dataSource, updateCallback) {
		var $element = $(element);
		this.element = element;
		this.$element = $element;
		element.autoSuggest = this;
		
		this._createAndInsertSuggestionList();
		if (dataSource) {
			$element.data(SOURCE_ATTRIBUTE, dataSource);
		}
		if (typeof updateCallback === 'function') {
			// register a callback function for when a selection
			// is made in the suggestion list
			this._updateCallback = $.proxy(updateCallback, this);
		}
		
		$element.on("keyup", onKeyupInput);
		// onFocus was replaced with onClick because Expander is using onClick 
		// and that results in 2 events triggered at the same time(focus, click)
		// on getting focus, the suggestion list was expanded and collapsed immediately
		// TODO: find a better way of fixing this
		$element.on("focus", onFocusInput);
		$element.on("blur", onBlurInput);
	};
	
	AutoSuggest.initAll = function(selector) {
		$(selector || "INPUT[data-" + SOURCE_ATTRIBUTE + "]").each(function (idx, el) {
			if (!el.autoSuggest) {
				new AutoSuggest(el);
			}
		});
	};
	
	AutoSuggest.prototype.getSuggestionFilter = function() {
		var f = this.filter,
			$el = $(this.element);
		if (f == null) {
			var filterName = $el.data(FILTER_ATTRIBUTE),
				source = $el.data(SOURCE_ATTRIBUTE);
			if (filterName) {
				f = AutoSuggest.Filters[filterName.toLowerCase()];
			} else {
				if (source && source.indexOf("id:") === 0) 
					f = AutoSuggest.Filters.prefix;
			}
			this.filter = f;
		}
		return f;
	};
	
	AutoSuggest.prototype.getSuggestionMapper = function() {
		var pattern = $(this.element).data(MAPPER_ATTRIBUTE);
		if (pattern == null) {
			pattern = new Template("${this}");
		}
		if (this.mapper == null || (this.mapper.pattern != pattern)) {
			this.mapper = new Template("${" + pattern + "}");
		}
		return this.mapper;
	};
	
	AutoSuggest.prototype._createAndInsertSuggestionList = function() {
		var $container = $("<DIV class='autoSuggest' />"),
			$el = $(this.element), siblings;
		
		if ($el.closest('form').hasClass('query')) {
			siblings = $el.siblings('input[type=submit]');
			if (siblings.length > 0) {
				$container.insertAfter(siblings[0]);
			}
		} else {
			// append it after the actual input
			$container.insertAfter($el);
		}
		
		var $suggestionList = $("<UL class='links' />");
		$container.append($suggestionList);
		
		this.suggestionList = $suggestionList[0];
		this.$suggestionList = $suggestionList;
		this.suggestionList.autoSuggest = this;
		$suggestionList.on("click", onClickList);
		$suggestionList.on("mouseover", "LI", onMouseoverList);
		
		
		// do not invoke on hover, click, focus etc, expand/collapse only through API methods 
		this.element.setAttribute("data-invoke-on", "none");
		
		this.expander = new Expander(this.element, $suggestionList[0].parentNode);
		return this.suggestionList;
	};
	
	AutoSuggest.prototype.getLoadingLatency = function() {
		return DEFAULT_LOADING_LATENCY;
	};
	
	AutoSuggest.prototype.getMinCharsToSuggest = function() {
		var x = parseInt(this.$element.data(MIN_CHARS_ATTRIBUTE));
		return (isNaN(x) ? DEFAULT_MIN_CHARS_TO_SUGGEST : x);
	};
	
	AutoSuggest.prototype.getMaxSuggestions = function() {
		var x = $(this.element).data(MAX_SUGGESTIONS_ATTRIBUTE);
		return (isNaN(x) ? DEFAULT_MAX_SUGGESTIONS : x);
	};
		
	AutoSuggest.prototype.cancelCollapse = function() {
		if (this.collapseTimeout) {
			clearTimeout(this.collapseTimeout);
			this.collapseTimeout = null;
		}
	};
	
	AutoSuggest.prototype.prepareCollapse = function() {
		this._cancelLoadSuggestions();
		if (!this.collapseTimeout) {
			this.collapseTimeout = setTimeout($.proxy(this.element.expander.collapse,
					this.element.expander), BLUR_LATENCY);
		}
	};
	
	AutoSuggest.prototype._cancelLoadSuggestions = function() {
		// cancel a previous loading if any
		if (this.loadTimeout) {
			clearTimeout(this.loadTimeout);
			this.loadTimeout = null;
		}
	};
	
	AutoSuggest.prototype.inputSelectedSuggestion = function() {
		var $selected = this.$suggestionList.find("LI." + SELECTED_CLASS);
		if ($selected.length > 0) {
			var newValue = $selected.text();
			
			var input = this.element;
			if (input.value != newValue || HPUtils.getLocaleCode().language == "ja") {
				input.value = newValue;
				this.$element.trigger("change", "autosuggest");
				
				if (this._updateCallback) {
					this._updateCallback(this.originalSuggestions);
				}
			}
		}
	};

	AutoSuggest.prototype.setSelectedSuggestion = function(suggestionElement) {
		var $li = $(suggestionElement).closest("LI");
		if ($li.length == 0 || $li.parent()[0] != this.suggestionList)
			return;
		$li.addClass(SELECTED_CLASS);
		$li.siblings("LI").removeClass(SELECTED_CLASS);
	}
	
	AutoSuggest.prototype.moveSelectedSuggestion = function(offset) {
		if (!offset)
			return;
		var $selected = this.$suggestionList.find("LI." + SELECTED_CLASS);
		var $newSelected;
		var index;
		if ($selected.length == 0) {
			$newSelected = this.$suggestionList.find("LI");
			index = offset - 1;
		} else {
			$newSelected = (offset < 0 ? $selected.prevAll("LI") : $selected.nextAll("LI"));
			index = Math.abs(offset) - 1;
		}
		if ($newSelected.length == 0)
			return;
		if (index < 0) {
			index = Math.max($newSelected.length - index, 0);
		} else {
			index = Math.min(index, $newSelected.length - 1);
		}
		this.setSelectedSuggestion($newSelected.eq(index));
	};
	
	var JP_JA_NO_SUGGEST_RE = /^[a-zA-Z]+$/;
	
	/**
	 * @returns true if a list of suggestions must be created
	 */
	AutoSuggest.prototype.willSuggest = function() {
		return this.element.value.length >= this.getMinCharsToSuggest();
	}
	
	AutoSuggest.prototype.loadSuggestions = function(latency) {
		if (latency > 0) {
			this._cancelLoadSuggestions();
			this.loadTimeout = setTimeout($.proxy(this.loadSuggestions, this), latency);
			return;
		}
		
		// this is a workaround for Chrome to get focus on the element; don't ask why
		if (this.element.value == "") {
			this.element.value = " ";
			this.element.value = "";
		}
	
		// if not enough characters then no suggestions are provided
		if (!this.willSuggest()) {
			this.suggestionsLoaded(null);
			return true;
		}
		
		// used in ContentLoader
		this.ownerDocument = this.element.ownerDocument;
		var template = new Template($(this.element).data(SOURCE_ATTRIBUTE));
		this.suggestionLoader = ContentLoader.load(template.render(this.element).value, 
				this, this.suggestionsLoaded);
	};
	
	AutoSuggest.prototype.suggestionsLoaded = function(suggestions) {
		if (suggestions) {
			// deep copy the original object because the template alters it
			// this member is created in case it needs to be accessed in
			// the update callback
			this.originalSuggestions = $.extend(true, {}, suggestions);
			var s = this.getSuggestionMapper().render(suggestions).tokens[0];
			// this flattens the array, if it's bidimensional
			// if you need more than this, create a flatten function
			// for multidimensional arrays
			s = $.map(s, function (val) { return val; });
			var max = this.getMaxSuggestions();
			if (max > 0) {
				s = s.slice(0, max);
			}
			this.setSuggestions(s);
		} else {
			this.setSuggestions(null);
		}
		this.element.expander.setExpanded(this.suggestionList.childNodes.length > 0);
	};
	
	AutoSuggest.prototype.setSuggestions = function(s) {
		var $list = $(this.suggestionList);
		// clear the list
		$list.html("");
		if (s && s.length > 0) {
			for (var i = 0; i < s.length; i++) {
				this.addSuggestion(i, s[i]);
			}
		}
	};
	
	AutoSuggest.prototype.addSuggestion = function(i, s) {
		var filter = this.getSuggestionFilter(); 
		if (filter == null || filter.call(this, i, s)) {
			var $li = $("<LI><a href='#'>" + s + "</a></LI>");
			$(this.suggestionList).append($li);
		}
	}; 
	
	AutoSuggest.Filters = { 
			prefix : function(index, suggestion) {
				return this.element.value.length == 0 || suggestion.indexOf(this.element.value) == 0;
			},
			prefixignorecase : function(index, suggestion) {
				return this.element.value.length == 0 || suggestion.toLowerCase().indexOf(this.element.value.toLowerCase()) == 0;
			},
		
			contains : function(index, suggestion) {
				return suggestion.indexOf(this.element.value) >= 0;
			},
			
			containsignorecase : function(index, suggestion) {
				return suggestion.toLowerCase().indexOf(this.element.value.toLowerCase()) >= 0;
			},
			
			ignoresamevalue : function(index, suggestion) {
				return suggestion != this.element.value;
			},
			
			unique: function(index, suggestion) {
				var retval = true;
				$(this.$suggestionList).find("LI A").each(function (index, element) {
					if ($(element).text() == suggestion) {
						return retval = false;
					}
				});
				return retval;
			}
		};
	
		
	return AutoSuggest;
});

define("GlobalKeys", ["jquery"], function($) {
	var GLOBAL_KEY_ATTRIBUTE = "data-global-key";
	
	var onGlobalKey = function(event) {
		var link = globalKeys[event.keyCode];
		if (link) {
			$(link).trigger("click");
			event.preventDefault();
			event.stopPropagation();
			return false;
		}
	};
	
	var globalKeys = {};
	var globalKeyCount = 0;
	
	return ({
		KEY_CODES: {
			"backspace" : 8,
			"tab" : 9,
			"enter" : 13,
			"shift" : 16,
			"ctrl" : 17,
			"alt" : 18,
			"pause" : 19,
			"capslock" : 20,
			"esc" : 27,
			"escape" : 27,
			"page up" : 33,
			"page down" : 34,
			"end" : 35,
			"home" : 36,
			"left arrow" : 37,
			"up arrow" : 38,
			"right arrow" : 39,
			"down arrow" : 40,
			"insert" : 45,
			"delete": 46
		},
		
		GLOBAL_KEY_ATTRIBUTE: GLOBAL_KEY_ATTRIBUTE,
	
		/** Register a link to be activated on a key pressed.
		 * @param link the link
		 * @param key the key code when this link will activated. If not specified 
		 * the 'data-global-key' attribute of the link will be considered. If that attribute is missing too an error
		 * occurs. If the keyCode is not an integer or a valid key name, an error occurs
		 */
		registerGlobalLink: function(link, key) {
			if (!key) {
				key = link.getAttribute(GLOBAL_KEY_ATTRIBUTE);
			}
			if (!key || !key.split) {  
	            throw new TypeError("Key is not specified and attribute " + GLOBAL_KEY_ATTRIBUTE + " is missing");  
	        }
			
			var keys = key.split(",");
			
			for (var i = 0; i < keys.length; i++) {
				var key = keys[i].trim().toLowerCase();
				var keyCode = parseInt(key);
				if (isNaN(keyCode)) {
					keyCode = this.KEY_CODES[key];
				}
		        if (!keyCode) {  
		            throw new TypeError("Invalid key: '" + key + "'");  
		        }
				globalKeyCount++;
				globalKeys[keyCode] = link;
				// register the event on first global key
				if (globalKeyCount == 1) {
					$(link.ownerDocument).keydown(onGlobalKey);
				}
			}
		}
	});
});

/**
 * A slideshow with different effects between slides. It is nothing more than a DIV with the CSS class 'slideshow'
 * and its children are the actual slides.
 */

define("Slideshow", ["jquery", "JSUtils", "StringUtils", "GlobalKeys", "Template", "ContentLoader"], 
		function($, JSUtils, StringUtils, GlobalKeys, Template, ContentLoader) {

	var SLIDESHOW_CLASS = "slideshow";
	var SLIDE_CLASS = "slide";
	var SLIDESHOW_NAV_CLASS = "slideshowNav";
	var CURRENT_CLASS = "current";
	var DISABLED_CLASS = "disabled";
	var DUPLICATE_CLASS = "duplicate";
	var CONTAINER_CLASS = "container";
	var LOADING_CLASS = "loading";
	var PREVIOUS_CLASS = "previous";
	var NEXT_CLASS = "next";
	var SLIDE_SEPARATOR = "/";
	var SLIDESHOW_SEPARATOR = "|";
	var CYCLE_ATTRIBUTE = "data-cycle";
	var DEFAULT_SWIPE_DELTA = 100;
	
	/** Creates a new slideshow.
	 * @param container the DOM element containing the slides
	 * @param selected the selected slide given as an ID or DOM element
	 */
	var Slideshow = function(container, selected) {
		this.container = container;
		this.container.slideshow = this;
		var $container = $(container);
		$container.addClass(LOADING_CLASS);
		
		// no slides in this slideshow - do nothing else
		if (this.getSlides().length <= 0) {
			$container.removeClass(LOADING_CLASS);
			return;
		}
		
		this.plugins = [];
		for (var plugin in Slideshow.plugins) {
			if ($container.hasClass(plugin)) {
				this.plugins.push(new Slideshow.plugins[plugin](this));
			}
		}
		
		if (!selected) {
			// if no current slide specified, check if any slide was marked as current from HTML 
			// this is needed when you want to start the slideshow from a specific slide
			for (var i = 0, n = this.getSlides().length;  i < n; i++) {
				if (this.getSlides()[i].className.indexOf(CURRENT_CLASS) != -1) {
					selected = i;
					break;
				}
			}
		}
		this.setCurrent(selected ? selected : 0);
		
		// everything is loaded
		$container.removeClass(LOADING_CLASS);
		
		// register on hash change to enable navigation if not already registered
		if (!window.slideshow || !window.slideshow.hashChangeEventAdded) {
			$(window).on("hashchange", onhashchange);
			window.slideshow = {hashChangeEventAdded: true};
		}
		
		// initialize all counters that point to the current slideshow
		var counters = $(".slideshowCounter");
		var containerId = $container.attr("id");
		if ((containerId != null) && (counters.length > 0)) {
			for (var index = 0; index < counters.length; index++) {
				var $counter = $(counters[index]);
				var slideshowId = $counter.attr("data-for");
				if (slideshowId == containerId) {
					var counterTemplate = new Template($counter.attr("data-template"), "%");
					var slideshowObject = this;
					this.addEventListener(Slideshow.CURRENT_CHANGED_EVENT, function(){
						var context = {
								"current" : slideshowObject.getCurrentIndex() + 1,
								"total" : slideshowObject.slides.length
						}
						$counter.html(counterTemplate.render(context).value);
					});
				}
			}
		}
		// notify all counters to refresh
		this.fireEventListeners(this.createEvent(Slideshow.CURRENT_CHANGED_EVENT));
	};	

	/**
	 * @return the current slide as a DOM element.
	 */
	Slideshow.prototype.getCurrentElement = function() {
		return this.currentSlide;
	};
	
	/**
	 * For more complete documentation please refer to the slideshow reference.
	 * @param currentSlide the current slide given as a relative/absolute reference or DOM element
	 * @param rotating if true and the relative reference produces an over/underflow then move as like the slides 
	 * are positioned in a circle rather than a straight line.
	 * @return the newly current slide as a DOM element.
	 */
	Slideshow.prototype.setCurrent = function(currentSlide, rotating) {	
		var slides = this.getSlides();
		// if the new current slide parameter is given as a string
		if (currentSlide.substring) {
			currentSlide = currentSlide.trim();
						
			var step = 1;
			var i = currentSlide.indexOf("*view");
			if (i > 0 && i == currentSlide.length - "*view".length) {
				currentSlide = currentSlide.substring(0, i);
				step = this.getSlidesPerView();
			}
			i = currentSlide.indexOf("view");
			if (i > 0 && i == currentSlide.length - "view".length) {
				currentSlide = currentSlide.substring(0, i);
				step = this.getSlidesPerView();
			}
			
			switch (currentSlide.toString()) {
				case "next":
					currentSlide = this.getCurrentIndex() + 1 * step;
					break;
				case "previous":
					currentSlide = this.getCurrentIndex() - 1 * step;
					break;
				case "first":
					currentSlide = 0;
					break;
				case "last":
					currentSlide = slides.length - 1 * step;
					break;
				default:
					// if the new current slide is given as a relative integer to either last slide or the current one
					if (currentSlide.indexOf("last-") == 0) {
						var offset = parseInt(currentSlide.substring(5));
						currentSlide = slides.length - 1 - offset * step;
					} else if (currentSlide.indexOf("+") == 0) {
						var offset = parseInt(currentSlide.substring(1));
						currentSlide = this.currentSlide + offset * step;
					} else if (currentSlide.indexOf("-") == 0) {
						var offset = parseInt(currentSlide.substring(1));
						currentSlide = this.currentSlide - offset * step;
					} else {
						// if the slide index is given as an absolute number
						var index = parseInt(currentSlide);
						if (!isNaN(index)) {
							currentSlide = index;
						}
					}
			}
		}
		
		// if the current slide is unspecified
		if (currentSlide == null)
			return;
		
		// check the range of the new selected slide index
		if (!isNaN(currentSlide)) {
			if (rotating) {
				currentSlide %= slides.length;
				if (currentSlide < 0) {
					currentSlide = (currentSlide + slides.length) % slides.length;
				}
			} else {
				if (currentSlide < 0) {
					currentSlide = 0;
				}
				if (currentSlide >= slides.length) {
					currentSlide = slides.length - 1;
				}
			}
			currentSlide = slides[currentSlide];
		}
		
		// if the new current is the same one, does not make any sense to change it and just silently do nothing
		if (currentSlide == this.currentSlide) {
			return;
		}

		// fire the before change event
		var beforeEvent = this.createEvent(Slideshow.BEFORE_CURRENT_CHANGE_EVENT);
		beforeEvent.newValue = currentSlide;
		this.fireEventListeners(beforeEvent);

		// change the CSS class of the old and new current slide
		if (this.currentSlide) {
			$(this.currentSlide).removeClass(CURRENT_CLASS);
		}
		
		var oldCurrentSlide = this.currentSlide;
		this.currentSlide = currentSlide;
		$(currentSlide).addClass(CURRENT_CLASS);
		
		// load the slide content if necessary
		this.loadSlide(this.currentSlide);

		// fire the after change event
		var event = this.createEvent(Slideshow.CURRENT_CHANGED_EVENT);
		event.oldValue = oldCurrentSlide;
		this.fireEventListeners(event);
		
		if (this.container.getAttribute("data-update-location") == "true") {
			this.updateLocation();
		}
		
		return this.currentSlide;
	};
	
	/** Loads a slide if it has a data-source attribute specified. Please refer to ContentLoader documentation 
	 * for more information.
	 * @param slide the slide, as a DOM element, of which content are we going to load.
	 * @param reload if true, then it reloads the slide. Otherwise the slide will be loaded only once.
	 */
	Slideshow.prototype.loadSlide = function(slide, reload) {
		if (slide.getAttribute("data-source")) {
			if (!this.slideLoaded) {
				this.slideLoaded = {};
			}
			if (reload || !this.slideLoaded[slide]) {
				ContentLoader.loadElementContent(slide);
				this.slideLoaded[slide] = true;
			}
		}
	};
	
	/**
	 * @returns the current slide index.
	 */
	Slideshow.prototype.getCurrentIndex = function() {
		if (this.currentSlide) {
			return this.getSlides().indexOf(this.currentSlide);
		}
		return -1;
	};
		
	/**
	 * Moves the current slide with the given offset.
	 */
	Slideshow.prototype.moveCurrent = function(offset, rotating) {
		var selectedIndex = this.getCurrentIndex();
		if (selectedIndex >= 0)
			this.setCurrent(selectedIndex + offset, rotating);
	};
	
	Slideshow.prototype.getSlidesPerView = function() {
		var visibleWidth = this.container.offsetWidth;
		if (visibleWidth <= 0) {
			return 0;
		}
		var slides = this.getSlides();
		var i = this.getCurrentIndex();
		while (visibleWidth > 0 && i >= 0 && i < slides.length) {
			visibleWidth -= slides[i++].offsetWidth;
		}
		return i - this.getCurrentIndex();
	};
	
	Slideshow.prototype.addEventListener = function(type, listener) {
		if (!this.listeners) {
			this.listeners = {};
		}
		if (!this.listeners[type]) {
			this.listeners[type] = [];
		}
		this.listeners[type].push(listener);
	};
	
	Slideshow.prototype.removeEventListener = function(type, listener) {
		if (!this.listeners) {
			return false;
		}
		if (!this.listeners[type]) {
			return false;
		}
		return JSUtils.removeElementFromArray(this.listeners[type], listener);
	};
	
	Slideshow.prototype.fireEventListeners = function(event) {
		if (!this.listeners) {
			return;
		}
		if (!this.listeners[event.type]) {
			return;
		}
		for (var i = 0; i < this.listeners[event.type].length; i++) {
			this.listeners[event.type][i].call(this, event);
		}
	};
	
	Slideshow.prototype.createEvent = function(type) {
		return {"target" : this, "type" : type};
	};
	
	/**
	 * @return the slides in this slideshow as an array, not a node list
	 */
	Slideshow.prototype.getSlides = function() {
		if (!this.slides) {				
			var slideClassPresent = false;
			var slides = [];
			var it = (this.slidesContainer ? this.slidesContainer : this.container).firstChild;
			while (it != null) {
				if (it.tagName == "DIV") {
					// if we found one CSS slide class
					if ($(it).hasClass(SLIDE_CLASS)) {
						// ... and it's the first one, then remove all the previous slides
						if (!slideClassPresent) {
							slideClassPresent = true;
							slides = [];
						}
						slides.push(it);
					} else {
						// add a DIV without the slide CSS class as slide only if that class was not specified
						if (!slideClassPresent) {
							slides.push(it);
						}
					}
					
				}
				it = it.nextSibling;
			}
			this.slides = slides;
		}
		return this.slides;
	};
	
	/**
	 * @return the slideshow location as it will be used in the address bar
	 */
	Slideshow.prototype.getLocation = function() {
	    var location = "";
	    if (this.container.id) {
	    	location += this.container.id + SLIDE_SEPARATOR;
	    }
	    var currentSlide = this.currentSlide;
	    if (currentSlide.id != null && currentSlide.id != "") {
	    	location += currentSlide.id;
	    } else {
	    	location += this.getCurrentIndex();
	    }
	    return location;
	};
	
	/**
	 * Updates the address location with the location of this slideshow.
	 */
	Slideshow.prototype.updateLocation = function() {
		var location = this.getLocation();
		var i = location.indexOf(SLIDE_SEPARATOR);
		// create a regexp to match the old location
		var s = "($|^|[" + SLIDE_SEPARATOR  + SLIDESHOW_SEPARATOR + "!#])";
		var locRE = new RegExp(s + (i >= 0 ? location.substring(0, i + 1) : location) + "[A-Za-z0-9_-]*" + s);
		var hash = window.location.hash;
		var m = hash.match(locRE);
		if (m) {
			location = m[1] + location + m[2];
			hash = hash.replace(locRE, location);
		} else {
			// if we didn't find the new location, then let's add it
			hash += (hash != null && hash != "" ? SLIDESHOW_SEPARATOR : "!") + location;
		}
		// if we really did modify the address location, then let's change it
		// this is a check to avoid unnecessary event firing
	    if (window.location.hash != hash) {
    		window.location.hash = (hash == "" ? null : hash);
	    }
	};
	
	/** A reference to a slideshow comprising of a slideshow and slide reference. This is used to set a new current. */
	var SlideshowReference = function(link, doc) {
		var href = link.getAttribute ? link.getAttribute("href") : link;
		if (!doc) {
			doc = link.ownerDocument ? link.ownerDocument : document;
		}
		var idx = href.lastIndexOf("#");
		// TODO verify if href starts with the current URL - workaround only for IE
		if (idx >= 0) {
			href = href.substring(idx + 1);
		}
		
		idx = href.indexOf(SLIDE_SEPARATOR);
		
		var slideshow, slide;
		if (idx < 0) {
			// the slide is directly specified
			slide = doc.getElementById(href);
			if (!slide) {
				return;
			}
			$slideshow = $(slide).closest("." + SLIDESHOW_CLASS);
			if ($slideshow.length > 0) {
				slideshow = $slideshow[0];
			}
		} else {
			// the slide is specified relative to the slideshow
			slideshow = doc.getElementById(href.substring(0, idx));
			slide = href.substring(idx + 1);
		}
		if (!slideshow || !slide) {
			return;
		}
		
		this.slideshow = slideshow;
		this.cycle = link.getAttribute && link.getAttribute(CYCLE_ATTRIBUTE) == "true";
		this.slide = slide;
	};
	
	SlideshowReference.prototype.isValid = function() {
		return this.slideshow && this.slideshow.slideshow && this.slide;
	};
	
	SlideshowReference.prototype.isEnabled = function() {
		if (!this.isValid()) {
			return false;
		}
		
		var slideshow = this.slideshow.slideshow;
		
		switch (this.slide) {
			case "next":
			case "last":
				var slidesCount = slideshow.getSlides().length; 
						currentSlide = slideshow.getCurrentElement(), 
						currentSlideIndex = slideshow.getCurrentIndex();
				return (currentSlideIndex < slidesCount - 1);
			case "previous":
			case "first":
				var slidesCount = slideshow.getSlides().length; 
						currentSlide = slideshow.getCurrentElement(), 
						currentSlideIndex = slideshow.getCurrentIndex();
				return (currentSlideIndex > 0);
		}
		
		return true;
	};

	SlideshowReference.prototype.isCurrent = function() {
		var slideshow = this.slideshow.slideshow;
		return this.isValid() && (this.slide == slideshow.getCurrentElement()
				|| this.slide == slideshow.getCurrentElement().id
				|| this.slide == slideshow.getCurrentIndex());
	};
	
	SlideshowReference.prototype.go = function() {
		if (!this.isValid()) {
			return;
		}
		this.slideshow.slideshow.setCurrent(this.slide, this.cycle);
	};
	
	
	
	SlideshowReference.prototype.getSlideshowElement = function() {
		return this.slideshow;
	};
	
	SlideshowReference.prototype.getSlideshow = function() {
		return this.slideshow.slideshow;
	};
	
	/**
	 * Parses a hash for a given document and returns a map between a slideshow and a reference element.
	 */
	SlideshowReference.parseReferences = function(location, doc) {
		if (location.charAt(0) == "#")
			location = location.substring(1);
		if (location.charAt(0) == "!")
			location = location.substring(1);
		if (location == "")
			return [];
		var slideshowLocations = location.split(SLIDESHOW_SEPARATOR);
		var refs = [slideshowLocations.length];
		for (var i = 0; i < slideshowLocations.length; i++) {
			refs[i] = new SlideshowReference(slideshowLocations[i], doc);
		}
		return refs;
	};
		
	/** The slideshow navigation element. */
	Slideshow.Nav = {};

	/** To be used as an event handler for a navigation element whenever the slideshow current slide has changed. */
	Slideshow.Nav.update = function(event) {
		var link = this;

		var ref = new SlideshowReference(link);
		
		// sets if the navigation item is disabled or not 
		var disabled = !ref.isEnabled();
		link.disabled = disabled;
		var $link = $(link);
		if (disabled) {
			$link.addClass(DISABLED_CLASS);					
		} else {
			$link.removeClass(DISABLED_CLASS);					
		}
		
		// sets if the navigation item is marked as current or not
		if (ref.isCurrent()) {
			$link.addClass(CURRENT_CLASS);
		} else {
			$link.removeClass(CURRENT_CLASS);
		}
	};
	
	/** Updates the current slide to which the given link (or event) is referring to. */
	Slideshow.Nav.go = function(link) {
		var event = null;		
		// if the context is the navigation item
		if (this.tagName == "A") {
			event = link;
			link = this;
		} else if (link.target) {
			event = link;
			link = event.target;
		}
		
		// if this was used as an event handler
		if (link.target) {
			event = link;
			link = link.target;
			var $link = $(link);
			if (!$link.hasClass(SLIDESHOW_NAV_CLASS)) {
				$link = $link.closest("." + SLIDESHOW_NAV_CLASS);
				if ($link.length > 0)
					link = $link[0];
			} 
		}
		
		// create a slideshow reference from this link
		var ref = new SlideshowReference(link);

		// do the recurrences
		GLOBAL_RECURRENT_ACTIONS.doRecurrences(link);
		
		// and follow it if possible
		if (ref.isValid()) {
			ref.go();
			if (event) {
				event.preventDefault();
				event.stopPropagation();
				return false;
			}
		}
	};
	
	Slideshow.Nav.onTouchStart = function (event) {
		// if the context is the navigation item
		if (this.tagName == "A") {
			link = this;
		}
		
		// if this was used as an event handler
		if (link.target) {
			event = link;
			link = link.target;
			var $link = $(link);
			if (!$link.hasClass(SLIDESHOW_NAV_CLASS)) {
				$link = $link.closest("." + SLIDESHOW_NAV_CLASS);
				if ($link.length > 0)
					link = $link[0];
			} 
		}

 		// ignore multi-touches
		if (event.touches.length > 1) {
			return;
		}
	    var touch = event.touches[0];
		link.touchStart = { "pageX": touch.pageX, "pageY": touch.pageY };

		// workaround for Android devices bug for touchEnd array being empty
		event.preventDefault();
		return false;
	};
	
	Slideshow.Nav.onTouchEnd = function (event) {
		// if the context is the navigation item
		if (this.tagName == "A") {
			link = this;
		}
		
		// if this was used as an event handler
		if (link.target) {
			event = link;
			link = link.target;
			var $link = $(link);
			if (!$link.hasClass(SLIDESHOW_NAV_CLASS)) {
				$link = $link.closest("." + SLIDESHOW_NAV_CLASS);
				if ($link.length > 0)
					link = $link[0];
			} 
		}
		
		// ignore multi-touches
		if (event.touches.length > 1 || event.changedTouches.length > 1) {
			return;
		}
        var touch = event.touches.length > 0 ? event.touches[0] : event.changedTouches[0];
        // calculate the difference between the start and end coordinates, either horizontally or vertically
        var diffX = touch.pageX - link.touchStart.pageX;
        var diffY = touch.pageY - link.touchStart.pageY;
        var scrollX = diffX, scrollY = diffY;

        var invokeOn = link.getAttribute("data-invoke-on");
        if (invokeOn) {
        	invokeOn = invokeOn.split(",");
        	if (invokeOn.indexOf("swipe") < 0) {
	        	if (invokeOn.indexOf("swipe-x") < 0) {
	        		diffX = 0;
	        	}
	        	if (invokeOn.indexOf("swipe-y") < 0) {
	        		diffY = 0;
	        	}
        	}
        }
        
        var swipeDelta = parseInt(link.getAttribute("data-swipe-delta"));
        if (isNaN(swipeDelta)) {
        	swipeDelta = DEFAULT_SWIPE_DELTA;
        }
        
        var diff = (diffY == 0) ? Math.floor(diffX/swipeDelta) : 
        		(diffX == 0) ? Math.floor(diffY/swipeDelta) :
        		Math.max(Math.floor(diffX/swipeDelta), Math.floor(diffY/swipeDelta));
        if (diff > 0) {
        	// stopPropagation only when swipe is valid
    		// otherwise you won't be able to scroll on page
    	    event.preventDefault();
    		event.stopPropagation();
    		
        	//update slideshow
        	return Slideshow.Nav.go.call(link, event);
        } else if (diff == 0) {
        	// perform scrolling manually due to preventDefault from onTouchStart
        	if (scrollX > 30 || scrollY > 30) {
        		window.scrollBy(scrollX, scrollY);
        		return;
        	}
        	
        	// if no valid scrolling, check if any A elements are present and trigger click
        	// otherwise, you won't be able to click on slideshow slides when they contain links
        	if (event.target.tagName == "A") {
        		var linkToFollow = event.target.tagName;
        	} else {
        		// check if target has any A parent to trigger
        		var $links = $(event.target).parents("A");
        		if ($links.length) {
        			// get the closest A parent
        			var linkToFollow = $links[0];
        		}
        	}
        	if (linkToFollow) {	
        		$(linkToFollow).trigger('click');
        	}
        }
	};
	
	Slideshow.Nav.init = function(navElem) {
		$(navElem).each(function() {
			var navElem = this;
		
			// if the parameter is an element itself
			if (navElem.tagName == "A") {
				var ref = new SlideshowReference(navElem);
				if (!ref.isValid()) {
					return;
				}
				// register event to update on current slide change
				ref.getSlideshow().addEventListener(Slideshow.CURRENT_CHANGED_EVENT, $.proxy(Slideshow.Nav.update, navElem));
	
				
				var target = navElem.getAttribute("data-for");
				if (target) {
					target = navElem.ownerDocument.getElementById(target);
				}
				if (!target) {
					target = navElem;
				}
				var $target = $(target);
	
				switch (navElem.getAttribute("data-invoke-on")) {					
					case "swipe":
					case "swipe-x":
					case "swipe-y":
						// set up touch events for devices that support them (valid only if a container was specified)
						try {
							// add behavior for touch swipes
							$target.on("touchstart", target == navElem 
									? Slideshow.Nav.onTouchStart : $.proxy(Slideshow.Nav.onTouchStart, navElem));		
							$target.on("touchend", target == navElem 
									? Slideshow.Nav.onTouchEnd : $.proxy(Slideshow.Nav.onTouchEnd, navElem));		
						} catch (e) {
							// most probably touchscreen events are not supported, do nothing in that case
						}
						break;
					case "hover":
						$target.on("mouseover", target == navElem ? Slideshow.Nav.go : $.proxy(Slideshow.Nav.go, navElem));
					case "click":
					default:
						// register click event
						$target.click(target == navElem ? Slideshow.Nav.go : $.proxy(Slideshow.Nav.go, navElem));		
				}
				
				// update the navigation item status
				Slideshow.Nav.update.call(navElem);	
				
				GLOBAL_RECURRENT_ACTIONS.doRecurrences(navElem, true);
			} else {
				var slideshow = navElem.getAttribute("data-for");
				if (slideshow) {
					slideshow = navElem.ownerDocument.getElementById(slideshow);
				}
				
				if (!slideshow || !slideshow.slideshow) {
					return;
				}
				// we got the slideshow element, but we need the slideshow object
				slideshow = slideshow.slideshow;
	
				// render the template associated with the navigational element and populate the content
				Template.populateContent(navElem, {"slideshow": slideshow});
				
				// initialize all new generated navigation items
				$(navElem).find("A." + SLIDESHOW_NAV_CLASS).each(function(index) {
					Slideshow.Nav.init(this);
				});
				
				// if the navigation is a slideshow itself initialize it
				if ($(navElem).hasClass(SLIDESHOW_CLASS)) {
					new Slideshow(navElem);
				}			
			}
		});
	};
	
	var onhashchange = function(event) {
		var win = event.target;
		if (!win) {
			//TODO: find why this is null in IE8
			return;
		}
		var doc = win.document;
		var found = false;
		var refs = SlideshowReference.parseReferences(win.location.hash, doc);
		for (var i = 0; i < refs.length; i++) {
			if (refs[i].isValid() && !refs[i].isCurrent()) {
				refs[i].go();
				found = true;
			}
		}
		
		// did any of the slide references changed and we navigated to a new slide?
		// if yes, then event should stop
		if (found) {
			event.preventDefault();
			event.stopPropagation();
		}
	};
	
	Slideshow.init = function(elems) {
		var $elems = $(elems);
		if ($elems.length <= 0) {
			return;
		}
		var doc = $elems[0].ownerDocument;
		// find what is the current slide from the browser address bar, the fragment part after #
		var initialRefs = SlideshowReference.parseReferences(window.location.hash, doc);
		
		$elems.each(function() {
			var elem = this;
		    if (elem.slideshow == null) {
		    	var current = null;
		    	for (var j = 0; j < initialRefs.length; j++) {
		    		if (initialRefs[j].getSlideshowElement() == elem) {
		    			current = initialRefs[j].slide;
		    		}
		    	}
		    	new Slideshow(elem, current);
		    }			
		});
	};

	Slideshow.initAll = function() {
		// initialize slideshows
		Slideshow.init(Slideshow.SELECTOR);
		
		// initialize navigation
		Slideshow.Nav.init(Slideshow.Nav.SELECTOR);
	};
			
	Slideshow.CLASS = SLIDESHOW_CLASS;
	Slideshow.CURRENT_CHANGED_EVENT = "currentChanged";
	Slideshow.BEFORE_CURRENT_CHANGE_EVENT = "beforeCurrentChange";
	Slideshow.SELECTOR = "." + Slideshow.CLASS;
	Slideshow.Nav.CLASS = SLIDESHOW_NAV_CLASS;
	Slideshow.Nav.SELECTOR = "." + Slideshow.Nav.CLASS;
	
	
	
	var DuplicatesRotating = function(slideshow) {
		var slides = slideshow.getSlides();
		var d = slides[0].cloneNode(true);
		d.className += DUPLICATE_CLASS;
		slides[0].parentNode.appendChild(d);
		d = slides[slides.length - 1].cloneNode(true);
		d.className += DUPLICATE_CLASS;
		slides[0].parentNode.insertBefore(d, slides[0]);
	};
	
	var DuplicateSlide = function(slideshow) {
		var slides = slideshow.getSlides();
		for (var i = 0, n = slides.length; i < n; i++) {
			var duplicateSlide = slides[i].ownerDocument.createElement("DIV");
			duplicateSlide.className = DUPLICATE_CLASS;
			var duplicateContentContainer = slides[i].cloneNode(true);
			duplicateSlide.appendChild(duplicateContentContainer);
			$(slides[i]).after(duplicateSlide);
			
			var contentContainer = slides[i].ownerDocument.createElement("DIV");
			contentContainer.className = CONTAINER_CLASS;
			contentContainer.className = slides[i].className;
			contentContainer.innerHTML = slides[i].innerHTML;
			$(slides[i]).empty();
			slides[i].appendChild(contentContainer);
		}		
	};
	
	var SoftflipEffect = function(slideshow) {
		var slides = slideshow.getSlides();
		for (var i = 0, n = slides.length; i < n; i++) {
			var containerSlide = slides[i].ownerDocument.createElement("DIV");
			containerSlide.className = CONTAINER_CLASS;
			slides[i].parentNode.appendChild(containerSlide);
			containerSlide.appendChild(slides[i]);
			
			var afterSlide = slides[i].ownerDocument.createElement("DIV");
			afterSlide.className = "after";
			containerSlide.parentNode.appendChild(afterSlide);
		}
		slideshow.addEventListener(Slideshow.CURRENT_CHANGED_EVENT, SoftflipEffect.afterCurrentChange);
	};
	
	SoftflipEffect.afterCurrentChange = function(event) {
		var slideshow = event.target;
		var slides = slideshow.getSlides();
		var currentSlide = slideshow.getCurrentElement();
		var oldCurrentSlide = event.oldValue;
		if (oldCurrentSlide) {
			$(oldCurrentSlide.parentNode).removeClass(CURRENT_CLASS);
			$(oldCurrentSlide.parentNode.nextSibling).removeClass(CURRENT_CLASS);
			$(oldCurrentSlide.parentNode).removeClass("gotoprev");
		}
		if (currentSlide) {
			$(currentSlide.parentNode).addClass(CURRENT_CLASS);
			$(currentSlide.parentNode.nextSibling).addClass(CURRENT_CLASS);
		}
		// we clicked previous
		if (oldCurrentSlide && currentSlide && slides.indexOf(currentSlide) < slides.indexOf(oldCurrentSlide)) {
			$(currentSlide.parentNode).addClass("gotoprev");
		}
	};
	
	var SlideflipEffect = function(slideshow) {
		var slides = slideshow.getSlides();
		for (var i = 0, n = slides.length; i < n; i++) {
			var containerSlide = slides[i].ownerDocument.createElement("DIV");
			containerSlide.className = CONTAINER_CLASS;
			slides[i].parentNode.appendChild(containerSlide);
			containerSlide.appendChild(slides[i]);
			
			var afterSlide = slides[i].ownerDocument.createElement("DIV");
			afterSlide.className = "after";
			containerSlide.parentNode.appendChild(afterSlide);
		}
		slideshow.addEventListener(Slideshow.BEFORE_CURRENT_CHANGE_EVENT, SlideflipEffect.beforeCurrentChange);
		slideshow.addEventListener(Slideshow.CURRENT_CHANGED_EVENT, SlideflipEffect.afterCurrentChange);
	};
	
	SlideflipEffect.beforeCurrentChange = function(event) {
		var slideshow = event.target;
		var slides = slideshow.getSlides();
		var currentSlide = slideshow.getCurrentElement();
		var newCurrentSlide = event.newValue;
		if (currentSlide && newCurrentSlide && slides.indexOf(currentSlide) > slides.indexOf(newCurrentSlide)) {
			newCurrentSlide.parentNode.style.cssFloat = "left";
			currentSlide.parentNode.style.cssFloat = "";
			// super IE (see http://beradrian.wordpress.com/2007/12/13/cssfloat/ )
			newCurrentSlide.parentNode.style.styleFloat = "left"; 
			currentSlide.parentNode.style.styleFloat = "";
		}
	};
	
	SlideflipEffect.afterCurrentChange = function(event) {
		var slideshow = event.target;
		var slides = slideshow.getSlides();
		var currentSlide = slideshow.getCurrentElement();
		var oldCurrentSlide = event.oldValue;
		if (oldCurrentSlide) {
			$(oldCurrentSlide.parentNode).removeClass(CURRENT_CLASS);
			$(oldCurrentSlide.parentNode.nextSibling).removeClass(CURRENT_CLASS);
			
			$(oldCurrentSlide.parentNode).removeClass("fromNext");
			$(oldCurrentSlide.parentNode).removeClass("fromPrevious");
		}
		if (currentSlide) {
			$(currentSlide.parentNode).addClass(CURRENT_CLASS);
			$(currentSlide.parentNode.nextSibling).addClass(CURRENT_CLASS);
		}
		
		$(currentSlide.parentNode).addClass( 
				(oldCurrentSlide && currentSlide && slides.indexOf(currentSlide) < slides.indexOf(oldCurrentSlide)
					? "fromNext" : "fromPrevious"));
	};
	
	var MultiSlidingEffect = function(slideshow) {
		this.slideshow = slideshow;
		var container = slideshow.container.ownerDocument.createElement("DIV");
		slideshow.container.appendChild(container);
		container.className = "container";
		
		var slides = slideshow.getSlides();
		
		for (var i = 0, n = slides.length; i < n; i++) {
			container.appendChild(slides[i]);
		}
		
		slideshow.slidesContainer = container;
		
		slideshow.addEventListener(Slideshow.CURRENT_CHANGED_EVENT, MultiSlidingEffect.afterCurrentChange);
		
		slideshow.isSlideEnabled = MultiSlidingEffect.isSlideEnabled;
	};
	
	MultiSlidingEffect.afterCurrentChange = function(event) {
		var slideshow = event.target;
		var currentSlide = slideshow.getCurrentElement();
		var visibleWidth = currentSlide.parentNode.parentNode.offsetWidth;
		var actualWidth = 0;
		var slides = slideshow.getSlides();		
		for (var i = 0, n = slides.length; i < n; i++) {
			actualWidth += slides[i].offsetWidth;
		}
		// if all the slides are visible do nothing
		if (actualWidth < visibleWidth) {
			return;
		}
		
		// maximum sliding is the total width - visible width
		// this is done to not have any blank space on the right side
		var offsetLeft = - Math.min(currentSlide.offsetLeft, actualWidth - visibleWidth);
		
		// IE fix to enable animations; if the animate function is defined,
		// it uses jQuery to simulate css3 transitions
		if (window.animate) {
			var animateOptions = slideshow.animateOptions;
			var duration = ".5s";
			var complete = null;
			if (animateOptions) {
				duration = animateOptions.duration;
				complete = animateOptions.complete;
			}
			animate(currentSlide.parentNode, { left : offsetLeft }, duration, null, complete);
		} else {
			currentSlide.parentNode.style.left = offsetLeft + "px";	
		}
	};
	
	MultiSlidingEffect.isSlideEnabled = function (slideIndex) {
		var slideshow = this;
		return slideIndex < MultislidingEffect.getSlidingSlides(slideshow);
	};
	
	/**
	 * @param slideshow the slideshow object for which we return the number of sliding slides
	 * @return the number of first slides that can be slided. Using the multisliding effect more than one slide
	 * can be visible at a time. This way it does not make any sense that the last slides to be slided, as they're
	 * visible anyway.
	 * 
	 */
	MultiSlidingEffect.getSlidingSlides = function(slideshow) {
		var visibleWidth = slideshow.container.offsetWidth;
		if (visibleWidth <= 0) {
			return 0;
		}
		var slides = slideshow.getSlides();
		var i = slides.length;
		while (visibleWidth > 0 && i > 0) {
			visibleWidth -= slides[--i].offsetWidth;
		}
		// return a count, i is the index
		i++;
		// if the slides don't fit exactly, then increase with one, as we moved one more
		if (visibleWidth < 0) i++;
		if (i > slides.length) i = slides.length;
	};
	
	Slideshow.plugins = {
		"hardflip": DuplicateSlide,
		"multisliding": MultiSlidingEffect,
		"softflip": SoftflipEffect,
		"slideflip": SlideflipEffect,
		"rotating": DuplicatesRotating
	};

	
	var RECURRENCE = { ACTIONS: ["start", "stop", "toggle"], 
			DEFAULT_ID: "DEFAULT",
			ATTRIBUTE_NAME: "data-interval",
			SEPARATOR: ","};
	
	var RecurrentAction = function() {
	};
	
	RecurrentAction.prototype.start = function() {
		if (!this.interval) {
			this.interval = setInterval($.proxy(RecurrentAction.prototype.doOnce, this), this.time);
		}
	};
	
	RecurrentAction.prototype.stop = function() {
		if (this.interval) {
			clearInterval(this.interval);
			this.interval = null;
		}
	};
	
	RecurrentAction.prototype.toggle = function() {
		if (this.interval) {
			this.stop();
		} else {
			this.start();
		}
	};
	
	RecurrentAction.prototype.doOnce = function() {
		if (this.target && this.target.tagName == "A") {
			$(this.target).trigger("click");
		}
	};
	
	/**
	 * @param action has the format [(start|stop|toggle)/]time.
	 */
	RecurrentAction.prototype.doRecurrence = function(s, target, onlyAutoStart) {
		var action = "toggle";
		var idx = s.indexOf("/");
		if (idx > 0) {
			action = s.substring(0, idx);
			s = s.substring(idx + 1);
		} else {
			action = s;
			s = null;
		}
		if (action.indexOf("auto") == 0) {
			action = action.substring(4);
			if (!onlyAutoStart) {
				return;
			}
		}
		if (RECURRENCE.ACTIONS.indexOf(action) < 0) {
			throw new TypeError(action + " is not a valid action. Possible ones are " 
					+ RECURRENCE.ACTIONS.join(","));
		}
		var time = s ? parseInt(s) : null;
		if (isNaN(time) && action != "stop") {
			throw new TypeError(s + " must be a number.");
		}
		if (action != "toggle" && this.time != time) {
			this.stop();
		}
		this.time = time;
		this.target = target;
		switch(action) {
			case "start":
				this.start();
				break;
			case "stop":
				this.stop();
				break;
			default:
				this.toggle();
		}
	};
	
	var RecurrentActions = function() {
		this.recurrentActions = {};
	};
	
	RecurrentActions.prototype.doRecurrences = function(link, onlyAutoStart) {
		var s = link.getAttribute(RECURRENCE.ATTRIBUTE_NAME);
		if (!s) {
			return;
		}
		var intervals = s.split(RECURRENCE.SEPARATOR);
		for (var i = 0, n = intervals.length; i < n; i++) {
			var s = intervals[i];
			var id = RECURRENCE.DEFAULT_ID, action;
			var idx = s.indexOf(":");
			if (idx > 0) {
				id = s.substring(0, idx);
				s = s.substring(idx + 1);
			}
			if (!onlyAutoStart || s.indexOf("auto") == 0) {
				var ra = this.recurrentActions[id];
				if (!ra) {
					ra = new RecurrentAction();
					this.recurrentActions[id] = ra;
				}
				ra.doRecurrence(s, link, onlyAutoStart);				
			}
		}
	};

	var GLOBAL_RECURRENT_ACTIONS = new RecurrentActions();
	
	Slideshow.RecurrentAction = RecurrentAction;
	Slideshow.RecurrentActions = RecurrentActions;
	
	
	return Slideshow;
});


define("Slider",["jquery",  "WindowUtils"], 
		function ($, WindowUtils) {
	
	var EVENT_MOUSE_DOWN = "mousedown";
	var EVENT_MOUSE_MOVE = "mousemove";
	var EVENT_MOUSE_END = "mouseup";
	var EVENT_MOUSE_OUT = "mouseout";

	var EVENT_TOUCH_START = "touchstart";
	var EVENT_TOUCH_MOVE = "touchmove";
	var EVENT_TOUCH_END = "touchend";
	var EVENT_TOUCH_CANCEL = "touchcancel";
	
	var ELEMENT_DIV = "DIV";
	var CLASS_SLIDER = "slider";
	var CLASS_SLIDER_CONTAINER = "sliderContainer";
	var CLASS_FADE_BEGIN = "atBegin";
	var CLASS_FADE_END = "atEnd";
	var ID_SLIDER_NAV = "sliderNav";
	var CLASS_NEXT_PREV_NAV = "nextPrevNav";
	var SLIDER_HORIZONTAL = "horizontal";
	var SLIDER_VERTICAL = "vertical";
	var ATTRIBUTE_NAVIGATION = "navigation";
	var ATTRIBUTE_ALIGN_SELECTOR = "slide-to";
	var NAVIGATION_DEFAULT = "default";
	var NAVIGATION_NONE = "none";
	var NAVIGATION_FADED = "faded";
	var NAVIGATION_ARROWS = "arrows";
	var FADE_WIDTH = 50;
	/**
	 * steps (number of presses on right or left) required to cross the part that is not viewed
	 */
	var NONTOUCH_SLIDER_STEPS = 5;
	
	var Slider = function(element) {
		this.element = element;
		this.sliderContainer = this.addSliderContainerElement(element); 
		this.sliderContainer.slider = this;
		this.navigation = $(element).data(ATTRIBUTE_NAVIGATION);
		this.mousePressed = false;
		this.horizontal = $(element).hasClass(SLIDER_HORIZONTAL);
		this.isTouch = WindowUtils.isTouchDevice();
		this.maxOffset = 0;
		this.startCoord = {x: 0, y:0};
		this.endCoord = {x: 0, y:0};
		
		switch (this.navigation) {
		case NAVIGATION_FADED:
			this.addFadeElements(element);
			break;
			
		case NAVIGATION_NONE:
			break;
			
		case NAVIGATION_ARROWS:
			this.addNextPrevNavElement(element);
			break;

		default:
			this.navigation = NAVIGATION_DEFAULT;
			if (this.isTouch) {
				this.addFadeElements(element);
			} else {
				this.addNextPrevNavElement(element);
			}
			break;
		}
		
		this.initAlignPosition(element);
		if (this.isTouch) {
			this.addTouchEvents();
		} else {
			this.addMouseEvents();
		}
	};
	
	Slider.init = function(elementClass) {
		var $elems = $("." + elementClass);
		if ($elems.length <= 0) {
			return;
		}
		
		$elems.each(function() {
			new Slider(this);
		});
	};
	
	Slider.prototype.addTouchEvents = function() {
		$(this.sliderContainer).on(EVENT_TOUCH_START, this.mouseDown);
		$(this.sliderContainer).on(EVENT_TOUCH_MOVE, this.mouseMove);
		$(this.sliderContainer).on(EVENT_TOUCH_END, this.mouseUp);
		$(this.sliderContainer).on(EVENT_TOUCH_CANCEL, this.mouseCancel);
	}
	
	Slider.prototype.addMouseEvents = function() {
		$(this.sliderContainer).on(EVENT_MOUSE_DOWN, this.mouseDown);
		$(this.sliderContainer).on(EVENT_MOUSE_MOVE, this.mouseMove);
		$(this.sliderContainer).on(EVENT_MOUSE_END, this.mouseUp);
		$(this.sliderContainer).on(EVENT_MOUSE_OUT, this.mouseOut);
	}
	
	
	Slider.prototype.mouseDown = function(event){
		this.slider.maxOffset = this.scrollWidth - this.offsetWidth;
		if (this.slider.maxOffset > 0) {
			if (this.slider.isTouch) {
				this.slider.startCoord.x = event.targetTouches[0].pageX;
				this.slider.startCoord.y = event.targetTouches[0].pageY;
			} else {
				this.slider.mousePressed = true;
				this.slider.startCoord.x = event.pageX;
				this.slider.startCoord.y = event.pageY;
			}
		}
		
		return true;
	}
	
    Slider.prototype.mouseMove = function(event) {
    	if (this.slider.maxOffset > 0) {
    		if (this.slider.isTouch) {
    			this.slider.endCoord.x = event.targetTouches[0].pageX;
    			this.slider.endCoord.y = event.targetTouches[0].pageY;
    		} else {
    			if (this.slider.mousePressed) {
    				this.slider.endCoord.x = event.pageX;
    				this.slider.endCoord.y = event.pageY;
    			}
    		}
    		
    		this.slider.updateStyle(this.slider.endCoord.x - this.slider.startCoord.x, this.slider.endCoord.y - this.slider.startCoord.y);
    		this.slider.startCoord.x = this.slider.endCoord.x;
    		this.slider.startCoord.y = this.slider.endCoord.y;
    	}
    	//fix android bug: touchmove is not fired propperly if event.preventDefault() is not used
		event.preventDefault();
    }
    
    Slider.prototype.mouseUp = function(event) {
    	if (this.slider.maxOffset > 0) {
	    	this.slider.startCoord = {x: 0, y:0};
	    	this.slider.endCoord = {x: 0, y:0};
	    	this.slider.mousePressed = false;
    	}
    	return true;
    }
    
    Slider.prototype.mouseOut = function(event) {
    	if ($(event.toElement).closest("." + CLASS_SLIDER_CONTAINER, this).length == 0) {
    		if (this.slider.maxOffset > 0) {
    			this.slider.startCoord = {x: 0, y:0};
    			this.slider.endCoord = {x: 0, y:0};
    			this.slider.mousePressed = false;
    		}
    	}
    	return true;
    }
    
    Slider.prototype.mouseCancel = function(event) {
    	if (this.slider.isTouch) {
    		if (this.slider.maxOffset > 0) {
    			this.slider.startCoord = {x: 0, y:0};
    			this.slider.endCoord = {x: 0, y:0};
    			this.slider.mousePressed = false;
    		}
    	}
    	return true;
    }
    
    Slider.prototype.nonTouchMovePrevious = function(event) {
    	event.preventDefault();
    	event.stopPropagation();
    	this.slider.maxOffset = this.slider.sliderContainer.scrollWidth - this.slider.sliderContainer.offsetWidth;
    	var newOffset = this.slider.getNonTouchMovePixels();
		this.slider.updateStyle(newOffset, 0);
		this.slider.updateBeginEndElements(this.nextElement, this, this.slider.sliderContainer.style.left, this.slider.maxOffset);
    }
    
    Slider.prototype.nonTouchMoveNext = function(event) {
    	event.preventDefault();
    	event.stopPropagation();
    	this.slider.maxOffset = this.slider.sliderContainer.scrollWidth - this.slider.sliderContainer.offsetWidth;
    	var newOffset = this.slider.getNonTouchMovePixels();
		this.slider.updateStyle(-newOffset, 0);
		this.slider.updateBeginEndElements(this, this.prevElement, this.slider.sliderContainer.style.left, this.slider.maxOffset);
    }
    
    Slider.prototype.getNonTouchMovePixels = function() {
    	return Math.min(Math.max(Math.ceil((this.sliderContainer.scrollWidth - this.sliderContainer.offsetWidth) / NONTOUCH_SLIDER_STEPS), 
    							 this.sliderContainer.offsetWidth / NONTOUCH_SLIDER_STEPS),
    					this.sliderContainer.offsetWidth);
    }
    
    Slider.prototype.updateStyle = function(changeX, changeY) {
		var newOffset = this.sliderContainer.offsetLeft + changeX;
		if (changeX < 0) {
			//swipe left
			this.sliderContainer.style.left = Math.max(newOffset, -this.maxOffset) + "px";
		}
		if (changeX > 0) {
			//swipe right
			this.sliderContainer.style.left = Math.min(newOffset, 0) + "px";
		}
		this.updateFadeElements(this.element, this.sliderContainer.style.left, this.maxOffset)
		if (this.sliderNav)
			this.updateBeginEndElements(this.sliderNav.nextElem, this.sliderNav.prevElem, this.sliderContainer.style.left, this.maxOffset);
    }

    Slider.prototype.addNextPrevNavElement = function(element) {
    	if ($(element).find(ELEMENT_DIV + "." + CLASS_NEXT_PREV_NAV).length == 0) {
			var nextPrevNav = document.createElement(ELEMENT_DIV);
			nextPrevNav.id = ID_SLIDER_NAV;
			nextPrevNav.className = CLASS_NEXT_PREV_NAV;
			var prevLink = document.createElement('a');
			prevLink.slider = this;
			$(prevLink).attr("href", "#slider/previous");
			$(prevLink).attr("class", "previous");
			var nextLink = document.createElement('a');
			nextLink.slider = this;
			$(nextLink).attr("href", "#slider/next");
			$(nextLink).attr("class", "next");
			nextPrevNav.appendChild(prevLink);
			nextPrevNav.appendChild(nextLink);
			$(nextPrevNav).width(element.clientWidth);
			element.appendChild(nextPrevNav);
			this.sliderNav = nextPrevNav;
			nextPrevNav.nextElem = nextLink;
			nextPrevNav.prevElem = prevLink;
			nextLink.prevElement = prevLink;
			prevLink.nextElement = nextLink;
			
			var delta = (this.sliderContainer.style.left == "") ? 0 : this.sliderContainer.style.left;
			this.updateBeginEndElements(nextLink, prevLink, delta, element.scrollWidth - element.clientWidth);
			
			//set events handlers on prev and next links
			$(prevLink).click(this.nonTouchMovePrevious);
			$(nextLink).click(this.nonTouchMoveNext);
    	}
    }
    Slider.prototype.addFadeElements = function(element) {
    	$(this.element).addClass(CLASS_FADE_BEGIN);
    	$(this.element).addClass(CLASS_FADE_END);
    	var delta = (this.sliderContainer.style.left == "") ? 0 : this.sliderContainer.style.left;
    	this.updateFadeElements(this.element, delta, element.scrollWidth - element.clientWidth);
    }
    
    Slider.prototype.addSliderContainerElement = function(element) {
    	var newSliderContainer = document.createElement(ELEMENT_DIV);
    	newSliderContainer.className = CLASS_SLIDER_CONTAINER
    	
    	var sliderContent = $(element).children().wrapAll(newSliderContainer)[0];
    	if ($(sliderContent).parent()[0])
    		newSliderContainer = $(sliderContent).parent()[0];
    	return newSliderContainer;
    }
    
    /**
     * remove or add the arrows or fade elements
     * @param delta - the left or top delta from the starting position
     */
    Slider.prototype.updateBeginEndElements = function(nextElement, prevElement, delta, maxOffset) {
    	delta = (delta == "") ? 0 : parseInt(delta);
    	if (prevElement) {
	    	if (delta == 0)
	    		$(prevElement).hide();
	    	else
	    		$(prevElement).show();
    	}
    	
    	if (nextElement) {
	    	if (delta + maxOffset == 0)
	    		$(nextElement).hide();
	    	else
	    		$(nextElement).show();
    	}
    }
    
    Slider.prototype.initAlignPosition = function(element) {
		this.maxOffset = this.sliderContainer.scrollWidth - this.sliderContainer.offsetWidth;
		var alignPos = this.calcAlignPosition();
		this.updateStyle(alignPos.x, alignPos.y);
    }
    
    Slider.prototype.calcAlignPosition = function() {
    	var alignSelector = $(this.element).data(ATTRIBUTE_ALIGN_SELECTOR);
    	if (alignSelector) {
	    	var $aligner = $(this.element).find(alignSelector);
	    	var leftMargin = $aligner.offset().left + $aligner.width() - $(this.sliderContainer).offset().left;
	    	
	    	return {
	    	  	x: this.sliderContainer.offsetWidth - leftMargin - this.getWidthForBeginEndElems(), 
	    	  	y: 0
	    	};
    	}
    	
    	return {x: 0, y: 0};
    }
    
    Slider.prototype.getWidthForBeginEndElems = function() {
    	switch (this.navigation) {
		case NAVIGATION_ARROWS:
			return $("." + CLASS_SLIDER + " " + "#" + ID_SLIDER_NAV + " A.next").width();
			break;
		default: 
			if (!this.isTouch)
				return $("." + CLASS_SLIDER + " " + "#" + ID_SLIDER_NAV + " A.next").width();
			else 
				return FADE_WIDTH;
			break;
    	}
    	return 0;
    }
    
    Slider.prototype.updateFadeElements = function(element, delta, maxOffset) {
    	if (this.navigation == NAVIGATION_FADED || (this.navigation == NAVIGATION_DEFAULT && this.isTouch)) {
	    	delta = (delta == "") ? 0 : parseInt(delta);
	    	if ($(element).hasClass(CLASS_FADE_BEGIN)) {
		    	if (delta == 0)
		    		$(element).removeClass(CLASS_FADE_BEGIN);
	    	}
	    	else {
	    		if (delta != 0)
	    			$(element).addClass(CLASS_FADE_BEGIN);
	    	}
	    	
	    	if ($(element).hasClass(CLASS_FADE_END)) {
		    	if (delta + maxOffset == 0) { 
		    		$(element).removeClass(CLASS_FADE_END);
		    	} 
	    	} else {
	    		if (delta + maxOffset != 0) { 
	    			$(element).addClass(CLASS_FADE_END);
	    		}
	    	}
    	}
    }
    
	Slider.initAll = function() {
		Slider.init(CLASS_SLIDER);
	};
	
	return Slider;
});

define("Pagination", ["jquery", "ContentLoader", "WindowUtils", "HPUtils", "Template"],
		function($, ContentLoader, WindowUtils, HPUtils, Template) {
	"use strict"
	var SEPARATOR = ',';

	/**
	 * Called when new results are received, e.g. through AJAX. Assumes
	 * the context will be the pagination object.
	 */
	function moreResultsReceived(response) {
		var pagination = this;

		// TODO: Rewrite this logic.
		// 2. items should not be assumed as a holder for all the result logic, raw arrays should be used
		// 3. the pagination template should be referenced separately so that the data is not bundled
		// it has no relation and it could be a common use case to have to update that
		if (pagination.data && pagination.paginationData) {
			var results = {};
			// TODO: rewrite the method as an instance method
			updatePaginationNumbers(pagination.paginationData, pagination.direction);
			results.items = pagination.data.slice(pagination.paginationData.fromIndex, pagination.paginationData.toIndex);
			// pagination object added to the data to support updating multiple templates
			results.pagination = pagination.paginationData;
			// TODO: this is specific to just one template
			results.pagination.fromPagedIndex = results.pagination.fromIndex + 1;
			pagination.insertResults(results);
			if (pagination.paginationData.toIndex >= pagination.paginationData.elementsNo && pagination.moreButton) {
				// hide the button
				HPUtils.hide(pagination.moreButton);
			}
			
		} else if (pagination.moreButton) {
			//if this is not a More but a next/previous pagination no other things to do
		
			var btn = pagination.moreButton;
			pagination.insertResults(response);

			// when done appending, update the button if more results available
			var moreResultsUrl = response.moreResultsUrl ||
				(response.pagination && response.pagination.moreResultsUrl);
			if (moreResultsUrl) {
				// if the format parameter is not specified, add it
				if (moreResultsUrl.indexOf("format=json") < 0) {
					if (moreResultsUrl.indexOf("?") < 0) {
						moreResultsUrl += "?format=json";
					} else {
						moreResultsUrl += "&format=json";
					}
				}
				btn.href = moreResultsUrl;
			} else {
				// hide the button
				HPUtils.hide(btn);
			}
		}
		
		// do this for both cases - with or without pagination.data avaialable
		if (pagination.moreButton) {
			// hide the loading image
			$(pagination.moreButton).removeClass(HPUtils.LOADING_CLASS);

			// after getting the results scroll to the more button previous position if not visible
			WindowUtils.scrollSmooth(pagination.moreButtonOffset);
	
			// recreate the loader each time - most probably URL has changed
			pagination.loader = null;
		}
	}


	/**
	 * Helper function that loads additional results via AJAX.
	 *
	 * @param event The event that was triggered. Used to extract the target of the event,
	 * which is expected to be the link to the moreResults page.
	 */
	function getMoreResults(event) {
		event.preventDefault();
		var btn = event.currentTarget;
		var pagination = btn.pagination;
		if (!pagination || pagination.loader)
			return;

		if (pagination.moreButton) {
			//save button current position in order to scroll here after getting the results
			pagination.moreButtonOffset = WindowUtils.getOffsetRelativeTo(btn);
			// now, hide the more button and show the pretty animation
			$(btn).addClass(HPUtils.LOADING_CLASS);
			if (!pagination.data && btn.href.indexOf("json:") === 0) {
				var ids = btn.href.substring(5).split(",");
				// 1st ID should point to itemsSource and the 2nd to paginationJSON
				if (ids.length >= 2) {
					pagination.data = $.parseJSON($("#" + ids[0]).html()).items;
					pagination.paginationData = $.parseJSON($("#" + ids[1]).html()).pagination;
				}
			}
		}
		// if we already have all the data in the object, we hit the callback directly
		if (pagination.data && pagination.paginationData) {
			pagination.direction = event.currentTarget.className;
			moreResultsReceived.call(pagination, pagination.data);
		} else {
			pagination.loader = ContentLoader.load("ajax:" + btn.href, pagination, moreResultsReceived);
		}
	}

	/**
	 * Creates a new pagination object.
	 * @param el the element to which this pagination object will be attached to.
	 * @param data optional array of results
	 */
	var Pagination = function (el, data) {
		this.paginationElement = el;
		el.pagination = this;

		var moreButton = $(el).find(".more")[0];
		
		// show more results links and add AJAX behavior
		if (moreButton) {
			HPUtils.show(moreButton);
			moreButton.pagination = this;
			this.moreButton = moreButton;
			
			var $moreBtn = $(moreButton);
			// prevent more than one handler to be added
			// couldn't do this because $elem.data('events') is always undefined - don't know why
			$moreBtn.off("click", getMoreResults);
			$moreBtn.on("click", getMoreResults);
			
			//TODO if next/previous are default over more this should disappear
			// hide the DIV that holds next and previous page links
			$(el).find(".next").each(function (idx) {
				if (this.parentNode === moreButton.parentNode) {
					HPUtils.hide(this);
				} else {
					HPUtils.hide(this.parentNode);
				}
			});
			
		} else {
			//used for Next, Previous with JS only;
			var nextButton = $(el).find(".next")[0];
			var previousButton = $(el).find(".previous")[0];
			if (nextButton) {
				nextButton.pagination = this;
				this.nextButton = nextButton;
				// prevent more than one handler to be added
				// couldn't do this because $elem.data('events') is always undefined - don't know why
				$(nextButton).off("click", getMoreResults);
				$(nextButton).on("click", getMoreResults);
				
				if (previousButton) {
					previousButton.pagination = this;
					this.previousButton = previousButton;
					// prevent more than one handler to be added
					$(previousButton).off("click", getMoreResults);
					$(previousButton).on("click", getMoreResults);
				}
			}
		}
		
		// for the special case in which we have the data already
		// loaded in the page, we create a holder inside the pagination
		// object for it
		var newResultsButton = moreButton ? moreButton : (nextButton ? nextButton : null);
		if (newResultsButton && newResultsButton.href.indexOf("json:") === 0) {
			var ids = newResultsButton.href.substring(5).split(",");
			// check attribute is valid
			// 1st ID should point to itemsSource and the 2nd to paginationJSON
			if (ids.length >= 2) {
				// TODO: don't used a named "pagination" object, use a raw object instead
				this.paginationData = $.parseJSON($("#" + ids[1]).html()).pagination;
				// if we received filtered data, update the number of elements and the page count
				if (data) {
					this.paginationData.elementsNo = data.length;
					this.paginationData.pagesNo = Math.ceil(data.length / this.paginationData.elementsPerPage);
					if (this.paginationData.pagesNo == 1 && moreButton) {
						HPUtils.hide(moreButton);
					}
				} else {
					// TODO: modify the toNamedJSON tld utlity function
					// so that it can output JSON arrays directly and remove
					// the assumptions that the data items should be in the "items"
					// element
					this.data = $.parseJSON($("#" + ids[0]).html()).items;
				}
			}
		}
		if (data && data.length) {
			this.data = data;
			// TODO: if data is passed in directly and the buttons don't have
			// json references, build the paginationData object
		}
	};

	/**
	 * @returns an array of template objects used by this pagination object.
	 */
	Pagination.prototype.getTemplate = function() {
		var ids = $(this.nextButton ? this.nextButton : this.moreButton).data('template').split(SEPARATOR);
		return Template.getTemplates(HPUtils.getElementsByIds(ids));
	};

	/**
	 * @returns an array of elements to which the new results will be appended
	 */
	Pagination.prototype.getTarget = function() {
		var ids = $(this.nextButton ? this.nextButton : this.moreButton).data('target').split(SEPARATOR);
		var resultsList = HPUtils.getElementsByIds(ids);
		if (resultsList.length) {
			return resultsList;
		}
		return $(this.paginationElement).prev("UL, OL");
	};

	/**
	 * Inserts the results in the results element.
	 * @param results the result object retrieved from JSON.
	 */
	Pagination.prototype.insertResults = function(results) {
		var lists = this.getTarget();
		var templates = this.getTemplate();
		var additive = $(this.nextButton ? this.nextButton : this.moreButton).data("additive");
		if (!additive) {
			additive = "true";
		}
		additive = additive.split(SEPARATOR);

		$(lists).each(function(idx, list) {
			var content = templates[idx].render(results).value;
			// if not additive attributes specified, use the first one
			var add = additive[idx] ? additive[idx] : additive[0];
			if (add === "true") {
				$(list).append(content);
			} else {
				$(list).html(content);
			}
		});

		$(this.paginationElement).trigger("pageadded");
	};

	/**
	 * Initialize AJAX more results on a page by hiding the
	 * nextPage links if they exist and add the event behavior
	 * for the moreResults links.
	 */
	Pagination.initAll = function(doc) {
		var results = [];
		if (!doc) {
			doc = document;
		}
		var $paginations = $(".pagination");
		var containsPageParam = (location.href.indexOf("?page=") >=0 || location.href.indexOf("&page=") >=0);

		// no pagination component found or url contains page index -> do nothing
		if (!$paginations || containsPageParam) {
			return;
		}

		$paginations.each(function (idx) {
			// if already initialized, do thing
			if (this.pagination) {
				return;
			}
			var more = $(this).find(".more");
			var next = $(this).find(".next");
			if (more.length || next.length) {
				results.push(new Pagination(this));
			}
		});
		return results;
	};

	/**
	 * Update pagination numbers like current-page, from-index, to-index in order to
	 * reflect the page that will be shown after the user initiated event is completed.
	 * @param paginationNumbers pagination object, from JSON source
	 */
	function updatePaginationNumbers(paginationData, direction) {
		if (!paginationData) {
			return;
		}
		var pagesNo = paginationData.pagesNo,
			perPage = paginationData.elementsPerPage,
			oldCurrentPage = Math.min(paginationData.currentPage, pagesNo);

		if (direction === "next" || direction.indexOf("more") >= 0) {
			paginationData.previousPage = Math.min(oldCurrentPage, pagesNo - 1);
			paginationData.currentPage = Math.min(oldCurrentPage + 1, pagesNo);
			paginationData.fromIndex = Math.max(paginationData.previousPage, 0) * perPage;
			paginationData.nextPage = Math.min(paginationData.currentPage + 1, pagesNo);
		} else 	if (direction === "previous") {
			paginationData.previousPage = Math.max(oldCurrentPage - 2, 1);
			paginationData.currentPage = Math.max(oldCurrentPage - 1, 1);
			paginationData.fromIndex = (paginationData.currentPage -1) * perPage;
			paginationData.nextPage = Math.min(oldCurrentPage, pagesNo - 1);
		}
		paginationData.toIndex = Math.min(paginationData.currentPage * perPage, paginationData.elementsNo);
	}

	return Pagination;

});

define("Products", ["CustomInputRadio", "HPUtils"], function(CustomInputRadio, HPUtils) {

	/**
	 * Handle products landing page
	 */
	var ProductIndex = function() {};

	ProductIndex.init = function() {
		if ($('#products').length <= 0) return;
		$(document).on("change", "input[type=checkbox][name=oid], span.checkbox", function(e) {
			ProductIndex.disableCompare();
			ProductIndex.countChecked();
		});
		ProductIndex.disableCompare();
		ProductIndex.countChecked();
		$('.pagination').bind("pageadded", function (event) {
			CustomInputRadio.initAll("input[type=checkbox][name=oid]");
		});
	};

	ProductIndex.countChecked = function() {
	    var compareCount = $("input[type=checkbox][name=oid]:checked").length;

	    $('input[data-compare-submit]').each(function(index){
	        var compareLabel = $(this).val().split('(')[0].trim();
	        $(this).val(compareLabel + " (" + compareCount + ")");
	    });

	    $('input[name=oid] ~ label[for]').each(function(index){
	         var compareLabel = $(this).html().split('(')[0].trim();
	         var countLabel = $(this).siblings('input[name=oid]:checked').length === 0 ? "" : " (" + compareCount + ")";
	         $(this).html(compareLabel + countLabel);
	    });
	};

	ProductIndex.disableCompare = function() {
		if ($("input[type=checkbox][name=oid]:checked").length < 2) {
			$("input[type=submit][data-compare-submit='1']").attr("disabled", "disabled");
		}  else {
			$("input[type=submit][data-compare-submit='1']").removeAttr("disabled");
		}
	};

	ProductIndex.updateCompareCount = function() {
	};

	/**
	 * Handle product detail page
	 */
	var ProductDetail = function() {};

	ProductDetail.init = function() {
		if (!window.location.href.match(/.*\/(\w|_)+\/\w{2}(\/m)?\/products\/(\w|-)+\/product-detail.do.*/g) || !$("#ratings-link")) return;
		$(document).on("click", ".rating-container", function(e) {
			$("#ratings-link").trigger('click');
		});
	}

	/**
	 * Handle products compare page
	 */
	var ProductCompare = {};
	var REMOVE_BUTTON_SELECTOR = "input[type=button][data-anchor-for]";

	var removeTableColumn = function(table, col){
	    if (!(col >= 0)) return;
	    $('tr td:nth-child(' + (col + 1) +'), tr th:nth-child(' + (col + 1) +')', table).remove();
	};

	ProductCompare.init = function() {
		if (!window.location.href.match(/.*\/(\w|_)+\/\w{2}(\/m)?\/products\/(\w|-)+\/compare.do.*/g))  return;

		$removeButtons = $(REMOVE_BUTTON_SELECTOR);
		for (var i=0; i<$removeButtons.length; i++) {
			$button = $($removeButtons.get(i));
			HPUtils.hide($("#" + $button.attr("data-anchor-for")));
			HPUtils.show($button);
		}
		$(document).on("click", REMOVE_BUTTON_SELECTOR, function(e) {
			ProductCompare.onClickHandler(e);
		});
		ProductCompare.disableRemove();
	};

	ProductCompare.onClickHandler = function(event) {
		var $buttonTD = $(event.target).closest("td");
		var $buttonTR = $(event.target).closest("tr");
		var $buttonTable = $(event.target).closest("table");

		removeTableColumn($buttonTable, $buttonTD[0].cellIndex);
		$buttonTable.css('width', $buttonTable.attr('data-screen-width') / 2 * $buttonTR.children().length);
		ProductCompare.disableRemove();
	};

	/**
	 * Disable remove product if we compare only 2 products
	 */
	ProductCompare.disableRemove = function() {
		if ($(REMOVE_BUTTON_SELECTOR).length < 3) {
			$(REMOVE_BUTTON_SELECTOR).attr("disabled", "disabled");
		}
	};

	return {
		"init": function() {
			ProductIndex.init();
			ProductDetail.init();
			ProductCompare.init();
		}
	};
});

define("Brightcove", ["jquery", "DocUtils", "HPUtils"], function ($, DocUtils, HPUtils) {
	"use strict"
	var SCRIPT_SRC = "//admin.brightcove.com/js/BrightcoveExperiences.js";
	var LOADING_CLASS = "loading";
	var BRIGHTCOVE_CLASS = "BrightcoveExperience";
	var HIDDEN_CONTAINER_TAG = "DIV";
	// don't use "invisible" because video will not be rendered in iPhone
	var HIDDEN_CONTAINER_CLASS = "collapsed";
	
	var Brightcove = function() {};
	
	var onThumbnailClick = function(event) {
		var thumb = event.currentTarget;
		// hide thumbnail
		HPUtils.hide(thumb);

		var $videoContainer = $(thumb).siblings(HIDDEN_CONTAINER_TAG + "." + HIDDEN_CONTAINER_CLASS);
		// change video settings in order to start playing automatically after clicking on thumbnail
		var $video = $videoContainer.children("." + BRIGHTCOVE_CLASS);
		var videoSettingsAttribute = ($video[0].tagName == "OBJECT") ? "data" 
				: ($video[0].tagName == "IFRAME") ? "src" : null;
		if (videoSettingsAttribute) {
			var settings = $video.attr(videoSettingsAttribute);
			if (settings) {
				$video.attr(videoSettingsAttribute, settings.replace("autoStart=false", "autoStart=true"));
			}
		}
		// make video container visible
		$videoContainer.removeClass(HIDDEN_CONTAINER_CLASS);
		
		event.preventDefault();
		event.stopPropagation();
	};
	
	Brightcove.init = function () {	
		var $videos = $("." + BRIGHTCOVE_CLASS);
		if (!$videos || !$videos.length) {
			return;
		}

		//include Brightcove script
		var script = DocUtils.includeScript(SCRIPT_SRC);
		$(script).bind("load", function() {
			$videos.each(function (idx) {
				// make video visible
				var $video = $(this);
				var $videoSection = $video.parents(".section.video");
				if ($videoSection.length) {
					// check if video has thumbnail
					var $thumbs = $video.siblings("A.thumb");
					if ($thumbs.length) {
						$thumbs.on("click", onThumbnailClick, false);
						
						// add video in a container and hide it
						var $videoContainer = $video.parent(); 
						var $hiddenContainer = $("<" + HIDDEN_CONTAINER_TAG + "/>");
						$hiddenContainer.addClass(HIDDEN_CONTAINER_CLASS).append($video);
						$videoContainer.append($hiddenContainer);
					}
					
					// set video on loading
					$video.addClass(LOADING_CLASS);
					
					HPUtils.show($videoSection);
				}
				
			});
		});
	};
	
	return Brightcove;
});

define("SocialDrawer", [ "jquery", "DocUtils", "WindowUtils", "Template", "Expander"],
		function($, DocUtils, WindowUtils, Template, Expander) {
	"use strict"

	// data attributes that can be added on social drawer component (ex. data-language)
	var DATA_ATTRIBUTES =
		[ "language", "country", "business-unit", "addthis-host", "share-label" ];
	
	var SERVICE_FACEBOOK = 'Facebook';
	var SERVICE_ADDTHIS = 'AddThis';
	var SERVICE_TWITTER = 'Twitter';
	
	var MAP_KILL_SWITCH_TO_SERVICE_NAME = {
		'tweetbutton_show' : SERVICE_TWITTER,
		'addthis_show' : SERVICE_ADDTHIS,
		'fb_show' : SERVICE_FACEBOOK
	};
	
	var SOCIAL_DRAWER_KILL_SWITCH = 'socialdrawer_show';
	
	/** 
	 * Social service representation
	 * @param config - service specific configuration object
	 */	
	var SocialService = function(config) {
		this.config = config;
	};
	
	SocialService.prototype = {
	    /**
	     * Always call this before using a social service.
	     * @param parent DOM node where service specific HTML code will be added
	     * @param context context used for rendering service specific HTML or JS code
	     */
	    init: function(parent, context) {
	    	// render code components by replacing tokens with values from the given context
	    	this.config.render(context);
	    	
			// insert service HTML code in the given parent node
	    	if (this.config.html) {
		    	var $container = $("<div/>");
			    $container.addClass("servicewrapper" +
			            (this.config.className ? " " + this.config.className : ""));
			    $container.append(this.config.html);
			    $(parent).append($container);
	    	}
	    	
		    // insert service script into the page
		    if (this.config.script) {
		    	DocUtils.includeScript(this.config.script, true);
		    }
		}
	};
	
	var SocialServiceFactory = {
		build: function(serviceType) {
			switch(serviceType) {
				case SERVICE_FACEBOOK:
					return new SocialService(FacebookConfig);
				case SERVICE_TWITTER:
					return new SocialService(TwitterConfig);
				case SERVICE_ADDTHIS:
					return new SocialService(AddThisConfig);
				default:
					throw "Not Supported Social Service Type";
			}
		}
	};
	
	var FacebookConfig = {
		// Id of the facebook application associated to the facebook like button.
		fbApplicationId : "185944354777267",   			
		
		// Supported language codes and countries for the Facebook like button
		supportedLanguages : [ "af_ZA", "sq_AL", "ar_AR", "hy_AM",
				"ay_BO", "az_AZ", "eu_ES", "be_BY", "bn_IN", "bs_BA",
				"bg_BG", "ca_ES", "ck_US", "hr_HR", "cs_CZ", "da_DK",
				"nl_NL", "nl_BE", "en_PI", "en_GB", "en_UD", "en_US",
				"eo_EO", "et_EE", "fo_FO", "tl_PH", "fi_FI", "fb_FI",
				"fr_CA", "fr_FR", "gl_ES", "ka_GE", "de_DE", "el_GR",
				"gn_PY", "gu_IN", "he_IL", "hi_IN", "hu_HU", "is_IS",
				"id_ID", "ga_IE", "it_IT", "ja_JP", "jv_ID", "kn_IN",
				"kk_KZ", "km_KH", "tl_ST", "ko_KR", "ku_TR", "la_VA",
				"lv_LV", "fb_LT", "li_NL", "lt_LT", "mk_MK", "mg_MG",
				"ms_MY", "ml_IN", "mt_MT", "mr_IN", "mn_MN", "ne_NP",
				"se_NO", "nb_NO", "nn_NO", "ps_AF", "fa_IR", "pl_PL",
				"pt_BR", "pt_PT", "pa_IN", "qu_PE", "ro_RO", "rm_CH",
				"ru_RU", "sa_IN", "sr_RS", "zh_CN", "sk_SK", "sl_SI",
				"so_SO", "es_LA", "es_CL", "es_CO", "es_MX", "es_ES",
				"es_VE", "sw_KE", "sv_SE", "sy_SY", "tg_TJ", "ta_IN",
				"tt_RU", "te_IN", "th_TH", "zh_HK", "zh_TW", "tr_TR",
				"uk_UA", "ur_PK", "uz_UZ", "vi_VN", "cy_GB", "xh_ZA",
				"yi_DE", "zu_ZA" ],
				
		className : "facebook",
		html : '<div id="fb-root" style="display: inline"></div><div class="fb-like" data-send="false" data-layout="box_count" data-show-faces="true"></div>',
		script : '(function(d, s, id) {\
					var js, fjs = d.getElementsByTagName(s)[0];\
					if (d.getElementById(id)) return;\
					js = d.createElement(s); js.id = id;\
					js.src = "//connect.facebook.net/${language}_${country}/all.js#xfbml=1&appId=${fbApplicationId}";\
					fjs.parentNode.insertBefore(js, fjs);\
					}(document, "script", "facebook-jssdk"));',
		
		/** function used for rendering service specific HTML or Script code template */
		render : function(ctx) {
			var fbCtx = { fbApplicationId : this.fbApplicationId };
			if (!ctx.language || !ctx.country ||
					this.supportedLanguages.indexOf(ctx.language + "_" + ctx.country.toUpperCase()) < 0) {
				fbCtx.language = "en";
				fbCtx.country  = "US";
			} else {
				fbCtx.language = ctx.language;
				fbCtx.country  = ctx.country.toUpperCase();
			}
			// render js
			this.script = new Template(this.script).render(fbCtx).value;
		}
	};

	var TwitterConfig = {
		// Supported language codes for the Twitter tweet button.
		supportedLanguages : [ "de", "es", "en", "fr", "it", "ja", "ko" ],
		 
		// code associated to the Twitter button
		className : "twitter",
		html : '<a href="https://twitter.com/share" class="twitter-share-button" \
					data-url="${url}" data-via="HP" data-lang="${language}" data-related="anywhereTheJavascriptAPI" data-count="vertical">Tweet</a>',
		script : "!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){"
				+ "js=d.createElement(s);js.id=id;js.src='//platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document,'script','twitter-wjs');",
				
		/** function used for rendering service specific HTML or Script code template */
		render : function(ctx) {
			var twCtx;
			if (!ctx.language || this.supportedLanguages.indexOf(ctx.language) < 0) {
				twCtx = ctx.clone();
				twCtx.language = "en";
			} else {
				twCtx = ctx;
			}
			twCtx.url = encodeURI(document.URL);
			this.html = new Template(this.html).render(twCtx).value;
		}
	};


	var AddThisConfig = {
		// code associated to the AddThis button.
		className : "addThis",
		html : '<a class="share" href="${addthis-host}/${country}/${language}/m/share.do?bu=${business-unit}">${share-label}</a>',
		
		/** function used for rendering service specific HTML or Script code template */
		render: function(ctx) {
			if (!ctx["addthis-host"]) {
				ctx["addthis-host"] = "";
			}
			this.html = new Template(this.html).render(ctx).value;
		}
	};


	/** Types of services that will be available in the drawer, in the specified order */
	var ACTIVE_SERVICES_TYPES = ["Twitter", "AddThis", "Facebook"];

	/** Html that must go inside the social drawer. */
	var drawerInnerHtml ='<div>\
						<a class="button primary collapsed right" href="#socialDrawerServices" data-position="below|right" data-scroll-to="false"></a>\
						<div id="socialDrawerServices"></div>\
					</div>';
	
	/**
	 * Constructor for the SocialDrawer object.
	 * @param socialDrawerComp - DOM node representing drawer component
	 * @param services - list of enabled services - code name
	 */
	var SocialDrawer = function($socialDrawerComp, services) {
		
		//populate drawer with HTML code
		$socialDrawerComp.html(drawerInnerHtml);
		
		// component needed for making social drawer floating
		this.$drawerLimit = $socialDrawerComp;
		this.$drawerContainer = $($socialDrawerComp.children()[0]);
		this.expandButton = this.$drawerContainer.children()[0];
		new Expander(this.expandButton);
		
		// context holding social services configuration - variables needed 
		// for rendering service specific HTML or JS code - .data - doesn't work with Zepto
		var configCtx = {};
		for (var i = 0, n = DATA_ATTRIBUTES.length; i < n; i++) {
			var attr =  DATA_ATTRIBUTES[i];
			configCtx[attr] = $socialDrawerComp.data(attr);
		}
		
		// lazy init for active social services 
		this.$servicesContainer = $(this.$drawerContainer.children()[1]);
		for ( var i = 0; i < services.length; i++) {
			var socialService = SocialServiceFactory.build(services[i]);
			if (socialService) {
				socialService.init(this.$servicesContainer, configCtx);
			}
		}
		
		updateWidth(this);
		updatePosition(this);
	};
	
	/**
	 * Initializer of the social drawer. It sets the events for which the social drawer is updated.
	 */
	SocialDrawer.init = function() {
		var $drawerComponent = $('#socialdrawer');
		if ($drawerComponent.length == 0) {
			return;
		}
		var cc = $drawerComponent.attr('data-country');
		var ll = $drawerComponent.attr('data-language');
		
		// read kill switch configuration
		$.ajax({
			type: 'GET',
			url: '/' + cc + '/' + ll + '/m/social/kill-switch-table.do',
			dataType: 'json',
			timeout: 10000,
			success: function(data) {
				
				// check is social drawer is enabled - socialdrawer_show = kill switch variable: true/false
				if (!data[SOCIAL_DRAWER_KILL_SWITCH]) {
					return;
				}
				
				var services = [];
				for (var switchName in MAP_KILL_SWITCH_TO_SERVICE_NAME) {
					if (data[switchName]) {
						services.push(MAP_KILL_SWITCH_TO_SERVICE_NAME[switchName]);
					}
			    }
				
				if (services.length == 0) {
					return;
				}
				
				var drawer = new SocialDrawer($drawerComponent, services);
				var updateFunction = function() {
					return updatePosition(drawer);
				};
				$(window).bind("scroll resize", updateFunction);
				$(document).bind("focus", updateFunction);
				$(drawer.expandButton).bind("click", function() { setTimeout(updateFunction, 200);});
			},
			error: function(xhr, type){
				if (console) {
					console.log(xhr, type);
				}
			}
		})
	};
	
	/**
	 * Updates the widths of the divs that contain the social services
	 * according to the number of available services.
	 */
	var updateWidth = function() {
		var width = Math.floor(100 / ACTIVE_SERVICES_TYPES.length);
		$(".servicewrapper").css("width", width + "%");
	};

	/**
	 * Updates the position of the social drawer in page according to
	 * the scroll position.
	 */
	var updatePosition = function(drawer) {
		var winHeight = $(window).height();
		var scrollPosition = $(window).scrollTop();
		var socialDrawerHeight = drawer.$drawerContainer.height();
	
		var bottomLimit = drawer.$drawerLimit.offset().top;
		if (bottomLimit < winHeight + scrollPosition) {
			drawer.$drawerContainer.css("position", "static");
			if (!drawer.expandButton.expander.isExpanded() && !drawer.fixed) {
				drawer.expandButton.expander.setExpanded(true);
			}
			drawer.fixed = true;
		} else {
			if (typeof (drawer.fixed) != "undefined" && drawer.fixed == true) {
				if (drawer.expandButton.expander.isExpanded()) {
					drawer.expandButton.expander.setExpanded(false);
				}
			}
			drawer.$drawerContainer.css("top",	winHeight + scrollPosition - socialDrawerHeight	+ "px");
			drawer.$drawerContainer.css("position", "absolute");
			drawer.fixed = false;
		}
	};

	return SocialDrawer;
});

define("BingMapLayer", ["jquery", "HPUtils"], function ($, HPUtils) {
	"use strict"
	
	// Bing supported locales for mapcontrol available at http://msdn.microsoft.com/en-us/library/cc469974.aspx
	var SUPPORTED_LOCALES = ["cs-cz", "da-dk", "nl-be", "nl-nl", "en-au", "en-ca", "en-in", "en-gb", "en-us",
	                         "fi-fi", "fr-ca", "fr-fr", "de-de", "it-it", "ja-jp", "nb-no", "pt-br", "pt-pt", 
	                         "es-mx", "es-es", "es-us", "sv-se"];
	
	var currentLocale = HPUtils.getLocaleCode();
	var BING_LIBRARY_URL = "http://ecn.dev.virtualearth.net/mapcontrol/mapcontrol.ashx?v=7.0&onscriptload=bingMapsScriptLoaded" 
		+ ($.inArray(currentLocale.toString().toLowerCase(), SUPPORTED_LOCALES) >= 0 ? "&mkt=" + currentLocale : "");
		
	var API_KEY = "Au-j_tEs2A0in-M6rjXv5rrdkoOTCVnBooEjwcHgIwNIs0l8l4a3FiCle7SVTmf2";

	var createConfig = function (position, zoom, config) {
		if (!config) {
			config = {};
		}
		if (zoom) config.zoom = zoom;
		if (position) {
			if (position.length == 4) {
				config.bounds = Microsoft.Maps.LocationRect.fromEdges(position[0], position[1], position[2], position[3]);
			} else {
				config.center = new Microsoft.Maps.Location(position.latitude, position.longitude);
			}
		}
		return config;
	}

	/**
	 * Constructor for modeling objects.
	 */
	var BingMapLayer = function (el, loadedCallback) {
		// set the default configuration for the map
		var imgPrefix = '/ie/en/images/i/d/';
		if ($(el).data('default-marker') === 'point') {
			this.defaultMarkerConfig = { icon: imgPrefix + 'point.png', width: 22, height: 21 };
		} else {
			this.defaultMarkerConfig = { icon: imgPrefix + 'pin.png', width: 22, height: 28 };
		}

		// if the Bing Maps script was not loaded
		if (typeof Microsoft === 'undefined' || typeof Microsoft.Maps === 'undefined') {
			var that = this;
			window.bingMapsTemp = {
				reference : that,
				target : el
			};
			window.bingMapsScriptLoaded = function () {
				var config = {credentials : API_KEY};
				bingMapsTemp.reference.setRepresentation(
					new Microsoft.Maps.Map(bingMapsTemp.target, config));
				// delete all global references; delete doesn't work in IE8 so just "undefine" them.
				window.bingMapsTemp = undefined;
				window.bingMapsScriptLoaded = undefined;
				loadedCallback();
			};

			// load it - you can only do this async
			// it's no use to assign a callback to the script
			// loading, since it loads other scripts asynchronously
			// the url string contains the name of the callback that
			// will get called once everything is set up
			$.getScript(BING_LIBRARY_URL);
			// do nothing else, the callback will make sure
			// that the representation is set and remove the global references
			return;
		} else {
			// if the library is loaded, just initialize the object
			var config = createConfig({credentials : API_KEY});
			this.setRepresentation(new Microsoft.Maps.Map(el, config));
			loadedCallback();
		}
	};

	BingMapLayer.prototype.update = function (position, zoom) {
		if (position instanceof Microsoft.Maps.LocationRect) {
			this.representation.setView({ bounds : position });
		} else {
			this.representation.setView(createConfig(position, zoom));
		}
	};
	
	/**
	 * Creates all the events needed for the map infobox object and attaches
	 * them to the corresponding pin.
	 * @param map the Bing Maps object the representation is attached to
	 * @param pin the pin associated with the infobox
	 * @param infobox the object holding the initial infobox options. If falsy, the
	 * method does nothing
	 */
	var setUpInfobox = function (mapObj, pin, infobox) {
		if (!infobox) return;
		
		var displayInfobox = function (e) {
			if (e.targetType === "pushpin") {
				var pin = e.target,
					infobox = pin.getInfobox();
					
				

				// on mouseover, we want to change the properties only 
				// if the infobox is not already displayed
				if (!(e.eventName === 'mouseover') || !infobox.getVisible()) {
					// we're using the ignored showCloseButton option as a
					// flag to indicate if the infobox should be persistent
					// (only close when x is pressed) or should close on mouseout
					infobox.setOptions({ visible: true, showCloseButton: e.eventName === 'click' });
				}
				var $closeButton = $('.mapInfoBox[data-infobox-id=' + infobox.getId() + '] .closeInfoBox');
				if (e.eventName === 'mouseover') {
					$closeButton.hide();
				}
				$closeButton.on('click', function () {
					infobox.setOptions({ visible : false });
					return false;
				});
			}
		};
		
		var closeInfobox = function (e) {
			if (e.targetType === "pushpin") {
				infobox = e.target.getInfobox();
				var $closeButton = $('.mapInfoBox[data-infobox-id=' + infobox.getId() + '] .closeInfoBox');
				
				if (e.eventName === 'mouseout') {
					$closeButton.show();
				}
				// we avoid hiding the infobox on mouseout when the flag has been set 
				if (!(e.eventName === 'mouseout') || !infobox.getShowCloseButton()) {
					infobox.setOptions({ visible: false });
					// on mouseout we unhide the close button so it will show up on click
				}
			}
			return false;
		};
		
		
		var initialLocation = infobox.getLocation();
		var resetInfoboxLocation = function (e) {
			infobox.setLocation(initialLocation);
			// re-add the event close handler - the infobox seems to be recreated and the handler is lost
			// TODO: code duplication - same thing in display
			$('.mapInfoBox[data-infobox-id=' + infobox.getId() + '] .closeInfoBox').on('click', function () {
				infobox.setOptions({ visible : false });
				return false;
			});
		}

		Microsoft.Maps.Events.addHandler(pin, 'click', displayInfobox);
		Microsoft.Maps.Events.addHandler(pin, 'mouseover', displayInfobox);
		Microsoft.Maps.Events.addHandler(pin, 'mouseout', closeInfobox);
		Microsoft.Maps.Events.addHandler(mapObj, 'viewchangeend', resetInfoboxLocation);
	}

	BingMapLayer.prototype.addMarker = function (position, config, infoboxConfig) {
		var pin, loc, infobox;

		loc = new Microsoft.Maps.Location(position.latitude, position.longitude);
		config = config ? config : this.defaultMarkerConfig;

		if (infoboxConfig) {
			infobox = new Microsoft.Maps.Infobox(loc, infoboxConfig);
			this.representation.entities.push(infobox);
			config.infobox = infobox;
		}
		pin = new Microsoft.Maps.Pushpin(loc, config);
		setUpInfobox(this.representation, pin, config.infobox);
		this.representation.entities.push(pin);
	};


	BingMapLayer.prototype.addMarkers = function (markers) {
		var that = this;
		$.each(markers, function (idx, marker) {
			that.addMarker(marker.position, marker.config, marker.infoboxConfig);
		});
	};

	BingMapLayer.prototype.clearMarkers = function (config) {
		if (!this.representation) return;
		var markers = this.representation.entities;
		if (!config) {
			markers.clear();
		} else {
			var i, toRemove = [];
			for (i = markers.getLength() - 1; i >= 0; i--) {
				if (markers.get(i)._icon === config.icon) {
					toRemove.push(i);
				}
			}
			$.each(toRemove, function (idx, val) {
				markers.removeAt(val);
			});
		}
	};

	BingMapLayer.prototype.addHandler = function (callback, eventName, target, ctx) {
		var handler = function (event) {
			if (e.targetType === "map") {
				var point = new Microsoft.Maps.Point(event.getX(), event.getY());
				callback.call(ctx, event, point, target);
			}
		};
		Microsoft.Maps.Events.addHandler(this.representation, eventName, handler);
	}

	BingMapLayer.prototype.setDefaultMarkerConfig = function (config) {
		this.defaultMarkerConfig = config;
	}

	BingMapLayer.prototype.setRepresentation = function (representation) {
		this.representation = representation;
	}

	return BingMapLayer;
});

define("MapLayer", ["jquery", "BingMapLayer"], function ($, BingMapLayer) {
	"use strict"
	/**
	 * Interface for the MapLayer strategies. 
	 */
 	var MapLayer = function (type, map, el, callback) {
 		this.el = el;
 		if (!MapLayer.types[type]) {
 			throw new Error("unsupported layer type - " + type);
 		}
 		this.map = map;
 		this.impl = new MapLayer.types[type](el, callback);
 	};
 	
 	MapLayer.prototype.getElement = function () {
 		return this.el;
 	}

 	/**
 	 * Centers the map layer around the supplied position
 	 * and sets its zoom level.
 	 */
 	MapLayer.prototype.update = function (position, zoom) {
 		this.map.update(position, zoom, this);
 		this.impl.update(position, zoom);
 	};

 	
 	MapLayer.expectedMethods = ["update"];
 	MapLayer.types = {};

 	/**
 	 * Adds a mapLayer implementation as an accepted type for this interface.
 	 * Checks to see all required methods are implemented.
 	 * Unfortunately, each type must be explicitly registered, I couldn't
 	 * find a better design here.
 	 **/
 	MapLayer.register = function (layerName, layerConstructor) {
 		var methods = MapLayer.expectedMethods,
 			types = MapLayer.types;
 		$.each(MapLayer.expectedMethods, function (idx, name) {
 			if (!layerConstructor.prototype.hasOwnProperty(name) 
 				|| typeof(layerConstructor.prototype[name]) !== "function") {
 				throw new Error("Map layer implementation does not have all the required methods.");
 			}
 		});

 		types[layerName] = layerConstructor;
 		return true;
 	};
	MapLayer.register("BingMapLayer", BingMapLayer); 	

	// delegates invocation of optional methods to the implementation
	// if it supports the requested method
	MapLayer.optionalMethods = ["addMarker", "addMarkers", "setDefaultMarkerConfig", "clearMarkers"];
	$.each(MapLayer.optionalMethods, function (idx, methodName) {
		MapLayer.prototype[methodName] = function () {
			if (typeof this.impl[methodName] === "function") {
				this.impl[methodName].apply(this.impl, arguments);
			}
		}
	});

 	return MapLayer;
});

define("Map", ["jquery", "MapLayer"], function ($, MapLayer) {
	"use strict"
	/**
		Mediator class that manages multiple map
		layers and keeps them in sync.
	 */
 	var Map = function (el, loaded) {
 		this.layers = [];
 		var that = this, count = 0,
 			loadedLayer = function () {
 				count = count + 1;
 				if (count == that.layers.length) {
 					loaded.call(null, that);
 				}
 			};
 		$(el).children('.layer').each(function (idx, el) {
 			var type = $(el).data('layer-type');
 			that.layers.push(new MapLayer(type, that, el, loadedLayer));
 		});
 	}; 

 	Map.prototype.update = function (position, zoom, sourceLayer) {
 		$.each(this.layers, function (idx, layer) {
 			if (layer != sourceLayer) {
 				layer.update(position, zoom);
 			}
 		});
 	};

 	Map.prototype.addLayer = function (layer) {
 		if ($.inArray(layer, this.layers) === -1) {
 			this.layers.push(layer);
 		}
 	};

 	Map.prototype.removeLayer = function (layer) {
 		var idx = $.inArray(layer, this.layers);
 		if (idx != -1) {
 			this.layers.splice(idx, 1);
 		}
 	}
 	
 	Map.prototype.getLayers = function (layerType) {
 		var results = [];
 		$.each(this.layers, function (idx, layer) {
 			if (layer instanceof layerType) {
 				results.push(layer);
 			}
 		});
 		return results;
 	};

 	Map.initAll = function (loaded) {
 		var maps = [];
 		$('.map').each(function (idx, el) {
 			maps.push(new Map(el, loaded));
 		});
 		return maps;
 	};

 	return Map;
});

define("BingGeocodingProvider", ["jquery", "ContentLoader", "HPUtils"], function ($, ContentLoader, HPUtils) {
	
	var REST_API_ENDPOINT = "http://dev.virtualearth.net/REST/v1/Locations",
		API_KEY = "Au-j_tEs2A0in-M6rjXv5rrdkoOTCVnBooEjwcHgIwNIs0l8l4a3FiCle7SVTmf2",
		LOCALE_CODE = HPUtils.getLocaleCode(),
		DIRECTIONS_URL_PREFIX = "http://www.bing.com/maps/default.aspx?mkt=" +  LOCALE_CODE + "&rtp=",
		MAP_DETAIL_URL_PREFIX = "http://www.bing.com/maps/default.aspx?v=2&style=r&mkt=" +  LOCALE_CODE + "&where1=";
		

	var BingGeocodingProvider = function () { };
	BingGeocodingProvider.API_KEY = API_KEY;
	BingGeocodingProvider.geocode = function (query, callback, ctx, language) {
		var jsonpCallbackName = "geocode" + (Math.floor(Math.random() * 10000)),
			requestParams = {
				query : encodeURI($.trim(query)),
				key : API_KEY,
				jsonp : jsonpCallbackName
			}, requestURI = REST_API_ENDPOINT + "?output=json", loader, handler;

		if (language) {
			requestParams.c = language;
		}

		$.each(requestParams, function (key, value) {
			requestURI += "&" + key + "=" + value;
		});

		handler = function (content) {
			// if we passed an element through the context we check if
			// it hasn't been updated before use the results - the results are no longer relevant
			if (ctx && ctx.element && loader.query != ctx.element.value) return;
			if (content.resourceSets.length && content.resourceSets[0].resources.length) {
				var resource = BingGeocodingProvider.getBestResourceFromContent(content);
				callback.call(ctx, resource);
			} else {
				callback.call(ctx, null);
			}
			// done executing
			// reset the variable by which the handler is identified
			window[jsonpCallbackName] = undefined;
		}
		handler.query = query;
		
		// save the query value to be checked when updated
		loader = ContentLoader.load("jsonp:" + jsonpCallbackName + ":" + requestURI, null, handler);
		loader.query = (query + " ").trim();
	}
	
		/* returns the result from bing that best matches the suggestion selected (or what the user inputed), 
	 or returns the first result */
	BingGeocodingProvider.getBestResourceFromContent = function(content) {
		var maxScore = BingGeocodingProvider.getScoreForResource(content.resourceSets[0].resources[0]);
		var maxIndex = 0;
		
		if (content.resourceSets[0].resources.length > 1) {
			for (var i = 1; i < content.resourceSets[0].resources.length; i++) {
				var resScore = BingGeocodingProvider.getScoreForResource(content.resourceSets[0].resources[i]);
				if (maxScore < resScore) {
					maxScore = resScore;
					maxIndex = i;
				}
			}
		}
		
		return content.resourceSets[0].resources[maxIndex];
	}
	
	BingGeocodingProvider.getScoreForResource = function(resource) {
		var score = 0;
		var inputedAddressUpperCase = $("#displayedAddress").val().toUpperCase();
		var city = resource.address.locality;
		var country = resource.address.countryRegion;
		if (resource.name && (inputedAddressUpperCase == resource.name.toUpperCase()))
			score += 9;// for japan we can have this case
		
		if (HPUtils.sameCountry(country, $('#displayedAddress').data('country-name')))
			score += 4;// if the resource country is the same as what the user selected
		
		if (city && (inputedAddressUpperCase.indexOf(city.toUpperCase()) != -1 || city.toUpperCase().indexOf(inputedAddressUpperCase) != -1))
			score += 3;// if the resource city is about the same as what the user selected
		
		return score;
	}

	BingGeocodingProvider.reverseGeocode = function (coords, callback, ctx, language) {
		if (!coords)
			return;

		var requestParams = {
				key : API_KEY,
				jsonp : "reverseGeocode"
		}, requestURI, loader, handler;

		if (language) {
			requestParams.c = language;
		}

		requestURI = REST_API_ENDPOINT + "/" + coords.latitude + "," + coords.longitude + "?output=json";
		$.each(requestParams, function (key, value) {
			requestURI += "&" + key + "=" + value;
		});
		
		handler = function (content) {
			if (content.resourceSets.length && content.resourceSets[0].resources.length) {
				var resource = content.resourceSets[0].resources[0];
				callback.call(ctx, resource);
			}
		}

		loader = ContentLoader.load("jsonp:reverseGeocode:" + requestURI, null, handler);
	}


	BingGeocodingProvider.bind = function (element, eventName, map, callback) {
		var language = $(element).data('language');
		
		if (map) {
			/** Event handler that gets triggered when the map is clicked.
			 *  The argument is a Bing API wrapper over the original JS event. **/
			var mapClickHandler = function (event) {
				if (event.targetType !== 'map') return;
				// do not change the cursor if we're trying to close an infobox
				if (event.originalEvent.target.className == 'closeInfobox') return;
				var point = new Microsoft.Maps.Point(event.getX(), event.getY());
				var loc = event.target.tryPixelToLocation(point);
				var position = { latitude: loc.latitude, longitude: loc.longitude };
				map.layers[0].clearMarkers(markerConfig);
				map.layers[0].addMarker(position, markerConfig);
				BingGeocodingProvider.reverseGeocode(position, callback, null, language);
			}
			// TODO: don't use the direct Bing layer representation, abstract using the map
			var bingMap = map.layers[0].impl.representation;
			Microsoft.Maps.Events.addHandler(bingMap, 'click', mapClickHandler);
		}
		
		/**
		 * Adds a marker on the designated location and centers the map on it.
		 */
		var updateMap = function (result) {
			if (result.bbox) {
				map.update(result.bbox);
			}
			var center = result.geocodePoints[0].coordinates;
			map.layers[0].addMarker({ lat : center[0], lon : center[1] }, markerConfig);
		}
		
		/** 
		 * Callback that gets triggered when a geocoding call originating from the
		 * value of the target element returns.
		 */
		var geocodingCallback = function (result) {
			// always trigger the callback; even if no result found 
			callback(result);
			if (map && result) {
				updateMap(result);
			}
		}, markerConfig = { icon: '/ie/en/images/i/d/point.png', height: 21, width: 22 };
		
		/** 
		 * This event handler triggers a geocoding call with the value in the target element,
		 * when the event identified by the eventName argument happens on the target. The
		 * geocodingCallback function is invoked with the results obtained from Bing.
		 * */
		$(element).on(eventName, function (event, source) {
			if (HPUtils.getLocaleCode().language != "ja" || (source == "autosuggest")) {
				BingGeocodingProvider.geocode($(this).val(), geocodingCallback, { element : this }, language);
			}
		});

		// if an initial location is set on the element, position the map to it
		if ($(element).data('initial-view')) {
			BingGeocodingProvider.geocode($(element).data('initial-view'), geocodingCallback, null, language);
		}
	}
	
	BingGeocodingProvider.getMapImageUrl = function (location, params) {
		var IMAGE_ENDPOINT = "http://dev.virtualearth.net/REST/v1/Imagery/Map/Road/",
			ZOOM_LEVEL = 14, url, coords;
		if (location.latitude && location.longitude) {
			coords = location.latitude + "," + location.longitude;
			url = IMAGE_ENDPOINT + coords + "/" + ZOOM_LEVEL;
			// add a pushpin to the center of 
			params.pp = coords;
		} else {
			// assume it's an address string
			url = IMAGE_ENDPOINT + encodeURI($.trim(location));
		}
		url += "?key=" + API_KEY;
		// add culture code
		url += "&c=" + LOCALE_CODE;
		$.each(params, function (key, value) {
			url += "&" + key + "=" + encodeURI(value);
		});
		return url;
	} 

	BingGeocodingProvider.getDirectionsUrl = function (destination, source) {
		var encodeForRoute = function (param) {
			if (param && param.latitude && param.longitude) {
				return "pos." + param.latitude + "_" + param.longitude;
			} else if (param) {
				return "adr." + encodeURI(param);
			}
			return "";
		}
		
		if (!source) {
			return DIRECTIONS_URL_PREFIX + "~" + encodeForRoute(destination);
		} else {
			return DIRECTIONS_URL_PREFIX + encodeForRoute(source) + "~" 
				+ encodeForRoute(destination);
		}
	}
	
	BingGeocodingProvider.getLargerMapUrl = function (address) {	
		return MAP_DETAIL_URL_PREFIX + encodeURIComponent(BingGeocodingProvider.prepareAddressForWebSearch(address));
	}
	
	BingGeocodingProvider.prepareAddressForWebSearch = function(address) {
		address = address.replace(/^\s+|\s+$/g,'');
		var re = /\/[^.:]{2,22}\/[A-Za-z]{2}\//;
		var countryCode = document.URL.match(re).toString().split('/')[1].toLowerCase();
		if (countryCode === 'emea_middle_east' || countryCode === 'lamerica_nsc_carib' || countryCode === 'lamerica_nsc_cnt_amer') {
				return address;
		}
		var currentCountry = $('#displayedAddress').data('country-name');
		if (address.toLowerCase().indexOf(currentCountry.toLowerCase()) < 0) {
				address = address + ', ' + currentCountry;
		}
		return address;
	}

	/**
	 * Receives an array of coordinates and returns a Bing LocationRect
	 * object that contains all of them.
	 */
	BingGeocodingProvider.getBoundingBox = function (points) {
		// returns true if the first value comes before the
		// second and false otherwise
		var checkLongitude = function (a, b) {
			return ((a-b) * (a-b > 180 ? -1 : 1)) < 0
		}
		var north = south = points[0].latitude, 
			east = west = points[0].longitude;

		$.each(points, function (idx, point) {
			if (point.latitude > north) {
				north = point.latitude;
			}
			if (point.latitude < south) {
				south = point.latitude;
			}
			if (checkLongitude(point.longitude, west)) {
				west = point.longitude;
			}
			if (checkLongitude(east, point.longitude)) {
				east = point.longitude;
			}
		});
		return Microsoft.Maps.LocationRect.fromEdges(north, west, south, east);
	}
	
	/**
	 * Receives a point of coordinates and returns top-left and bottom-right points 
	 * for a rectangle containing the initial point (+-1 minute latitude/longitude)
	 */
	BingGeocodingProvider.getBoxAroundGeoPoint = function(geoPoint) {
		var northEast = jQuery.extend(true, {}, geoPoint), southWest = jQuery.extend(true, {}, geoPoint);
		var temp = northEast.latitude;
		northEast.latitude =  (temp < 0 ? Math.ceil(temp) : Math.floor(temp)) + ((temp % 1) * 60 +1)/60;
		temp = northEast.longitude;
		northEast.longitude = (temp < 0 ? Math.ceil(temp) : Math.floor(temp)) + ((temp % 1) * 60 -1)/60;
		
		temp = southWest.latitude;
		southWest.latitude = (temp < 0 ? Math.ceil(temp) : Math.floor(temp)) + ((temp % 1) * 60 -1)/60;
		temp = southWest.longitude;
		southWest.longitude = (temp < 0 ? Math.ceil(temp) : Math.floor(temp)) + ((temp % 1) * 60 +1)/60;
		
		return [northEast, southWest];
	}

	return BingGeocodingProvider;
});

define("StoreFinder", ["jquery", "Template", "AutoSuggest", "HPUtils", "Map", "BingGeocodingProvider", "Pagination", "Expander"],
	function($, Template, AutoSuggest, HPUtils, Map, BingGeocodingProvider, Pagination, Expander) {
	"use strict"
	var StoreFinder = function() {};
	var map;
	
	var isMobileResultPage = ($(".nav").length == 0);
	
	var SEARCH_TYPES_CONTAINER_ID = "storeLocatorSearchTypesContainer";
	
	/**
	 * Do selective initialization, when used in conjunction with
	 * HPUtils.initModule.
	 */
	StoreFinder.checkForInit = true;
	// I don't know why this isn't set automatically - https://github.com/jrburke/requirejs/issues/352
	StoreFinder.id = "StoreFinder";
	StoreFinder.init = function() {
		var expandablesSelectors = ["#localareaSearchFields"];
		var isSlsSearchPage = isSearchPage();
		if (isSlsSearchPage) {
			var $segmentIDs = $("#bs > OPTION").map(function() { return $(this).val();});
			var searchByProductFieldsIDs = $.map($segmentIDs, function(item) { return "#searchByProductFields_seg" + item});
			var searchBySpecializationFieldsIDs = $.map($segmentIDs, function(item) { return "#searchBySpecializationFields_seg" + item});
			var searchByNameFieldsIDs = $.map($segmentIDs, function(item) { return "#searchByNameFields_seg" + item});
			
			// add expandable elements IDs specific to search page
			// there's no common function for merging arrays in jQuery and zepto
			expandablesSelectors = expandablesSelectors.concat(searchByProductFieldsIDs,
				searchBySpecializationFieldsIDs, searchByNameFieldsIDs, "#" + SEARCH_TYPES_CONTAINER_ID);
				
			// enable the find stores button only when the form is filled in
			HPUtils.enable("#content INPUT[type=submit]", isFormFilled());
			// recheck after each form element changes
			$(searchByProductFieldsIDs.join()).on("change", "INPUT[type=radio]", onFormElementChanged);
			$(searchBySpecializationFieldsIDs.join()).on("change", "SELECT", onFormElementChanged);
			$(searchByNameFieldsIDs.join()).on("change keyup", "INPUT[type=text]", onFormElementChanged);
			$("#localareaSearchFields").on("change keyup", "INPUT[type=text]", onFormElementChanged);
	        $("#bs,INPUT[name=searchBy]").on("change", onFormElementChanged);
	        
	        // check/uncheck corresponding radio buttons when a segment changes
	        $("#" + SEARCH_TYPES_CONTAINER_ID + " > UL").on("expand", function () { 
				var $searchOptions = $(this).find("INPUT[name=searchBy]");
		    	if ($searchOptions.length == 1) {
		    		// if only one search option is available, mark it as checked
		    		$searchOptions[0].checked = true;
		    	}
		    });
	        // if the active searchBy container has only one option available, check the corresponding radio
	        var $activeSearchOptions = $("#" + SEARCH_TYPES_CONTAINER_ID + " > UL.expanded INPUT[name=searchBy]");
	        if ($activeSearchOptions.length == 1) {
	        	$activeSearchOptions[0].checked = true;
	        }
		}
		// these elements should be present on both search and results page
		$("#searchTypeNationwide,#searchTypeLocalarea,INPUT[name=valid]").on("change", onFormElementChanged);
		
		// activates/deactivates form elements inside expandable components depending on expander state
		// join them due to an IE bug for $() on arrays
		var expandables = expandablesSelectors.join(); 
		$(expandables).bind("expand collapse", toggleFormElements);
		$(expandables).each(toggleFormElements);
	    
	    // hide address validation error messages when nationwide search is selected
	    // and show them, if needed, when nationwide search is not active
	    $("#searchTypeNationwide").on("expand collapse", validateAddress);
	    
	    var $displayedAddress = $("#displayedAddress");
	    $displayedAddress.keypress(function (e) {
	    	// reset location hidden fields
			$("INPUT[name=city],INPUT[name=zipCode],INPUT[name=cc]").val("");
			$("INPUT[name=valid]").val("false").change();
		});
		$("#localareaSearchFields #range.number, #localareaSearchFields #useRange").on("change", validateRange);
	    
	    map = initMap();
	    if (!map) {
	    	// call geocoding service each time address bar changes
		    BingGeocodingProvider.bind($displayedAddress[0], "change", null, updateFormElements);
	    }
	    
		// we attempt geolocation
		if (navigator.geolocation) {
			// in case of both success and error, we call the same function
			var callback = isSlsSearchPage ? geolocationCallback : geolocationCallbackNoMap;
			// in case of both success and error, we call the same function
			navigator.geolocation.getCurrentPosition(callback, callback);
		}
		if (!isSlsSearchPage) {
			 $("select[name=sortBy]").on("change", function(e) {
		    	var idx = e.target.selectedIndex;
		    	var sortedData = [];
		    	switch(idx) {
			    	case 0: 
			    		sortedData = getStoreData().sort(sortByBestMatch);
			    		break;
			    	case 1:
			    		sortedData = getStoreData().sort(sortyByName); 
			    		break;
			    	default:
			    		//no sort
		    	}
		    	// apply store name filters
		    	sortedData = filterStores(sortedData);
		    	updateResults(sortedData);
		    });
			
			initResultsPage(map);
		}
		
		// resize the left navigation when expanding elements to accommodate the new width
		var $nav = $(".nav");
		if ($nav.length > 0) {
			var $navExpander = $(".navExpander");
			var resizeNav = function(event) {
				// the timeout is necessary because the expander has the transitions 
				setTimeout( function() {
					var height = Math.max($nav.children("FORM").height(), $nav.nextAll("DIV").height());
					$nav.height(height + 10);
					if ($navExpander.length > 0) {
						// position navExpander; 90px is the height of heading + breadcrumb
						// min 250px to avoid overlap with text from partner details tab
						$navExpander[0].style.top = Math.max((height + 90) / 2, 250)  + "px";
					}
				}, 350);
			};
			$nav.bind("expand collapse", resizeNav);
			// resize when validation error messages appear or disappear
			$('INPUT[name=valid]').bind("change", resizeNav);
			resizeNav();
		}
	
		$("#storesLocaleSelector").addClass("overlayTooltip").append('<span class="arrow"><span>');
	};

	
	var currentPosition;
	// this should be called on results page
	var geolocationCallbackNoMap = function(position) {
		if (position && position.coords) {
			currentPosition = position.coords;
		} else {
			currentPosition = null;
		}
	}
	// call this on search page
	var geolocationCallback = function (position) {
		geolocationCallbackNoMap(position);
		updateMapWithGeolocation();
	};

	var isSearchPage = function () {
		return $("#bs").length > 0;
	};
	
	/**
	 * Initializes the table behavior and the store name
	 * filtering from the results page.
	 */
	var initResultsPage = function (map) {
		initTableInfoBox();
		initStoreNameFilter(map);
		var partnersMobileRelatedSectionSelector = "#partnersList > LI > UL.links.related";
		// test if mobile page
		if (!map && $(partnersMobileRelatedSectionSelector).length > 0) {
			// update with decorated partners results (directionsUrl)
			updateResults(getStoreData());
			
			// initialize expanders for partner details on the new added page
			$(".pagination").bind("pageadded", function (event) {
				var lastElemIndex = (this.pagination.paginationData.currentPage - 1) * this.pagination.paginationData.elementsPerPage - 1;
				$(partnersMobileRelatedSectionSelector).find("A.collapsed[href], A.expanded[href]").each(function(index, elem) {
					if (index > lastElemIndex) {
						new Expander(this);
					}
				});
			});
		}
	};

	var onFormElementChanged = function(event) {
		HPUtils.enable("#content INPUT[type=submit]", isFormFilled());
	};
	
	var isFormFilled = function() {
		var segId = $("#bs > OPTION.expanded"); //selected business segment ID
		if (segId.length > 0) {
			// search page
			segId = segId.val();
			return (($("#searchByProduct_seg"+segId+".expanded").length > 0 && $("#searchByProductFields_seg"+segId+" INPUT:checked").length > 0)
				|| ($("#searchBySpecialization_seg"+segId+".expanded").length > 0 && $("#searchBySpecializationFields_seg"+segId+" > SELECT").val().length > 0)
				|| ($("#searchByName_seg"+segId+".expanded").length > 0 && $("#partnerName_seg"+segId).val().length > 0)
				) && (($("#searchTypeLocalarea:checked").length > 0 && $("#displayedAddress").val().length > 0 && $("INPUT[name=valid]").val() === "true")
						|| $("#searchTypeNationwide:checked").length > 0) ;
		}
		
		// results page doesn't have a business segment dropdown, a hidden field is used instead
		segId = $("INPUT[name=bs]").val();
		var searchType = $("INPUT[name=searchBy]").val();
		return ((searchType == "PRODUCT" && $("#searchByProductFields INPUT:checked").length > 0)
			|| (searchType == "SPECIALIZATION" && $("#searchBySpecializationFields > SELECT").val().length > 0)
			|| (searchType == "NAME"))
			&& (($("#searchTypeLocalarea:checked").length > 0 && $("#displayedAddress").val().length > 0 && $("INPUT[name=valid]").val() === "true")
					|| $("#searchTypeNationwide:checked").length > 0) ;
	};
	
	/** Disables/activates form elements depending on expandable state */
	var toggleFormElements = function() {
		var $container = $(this);
		// for SEARCH_TYPES_CONTAINER_ID toggle only searchBy radio buttons
		var selector = ($container.parent.id != SEARCH_TYPES_CONTAINER_ID) ? "INPUT, SELECT" : "INPUT[name=searchBy]";
		var $formElements = $container.find(selector);
		if ($container.hasClass("expanded")) {
			$formElements.each(function() { this.disabled = false; });
		} else if ($container.hasClass("collapsed")) {
			$formElements.each(function() { this.disabled = true; });
		}
	};

	function getSelectOption($select) {
		return $select[0].options[$select[0].selectedIndex];
	};
	
	// for region names that cannot be geocoded
	var regionBoundingBoxes = {
			emea_africa: [34.54, -16.26, -26.06, 46.40],
			emea_middle_east : [42.10, 25.75, 18.97, 57.10],
			lamerica_nsc_carib:  [24.97, -85.13, 9.57, -57.87],
			lamerica_nsc_cnt_amer : [18.75, -93.85, 4.94, -75.46]
	};

	/** returns map object or null if map component is not available */
	function initMap() {
		var $mapComp = $(".map");

		if (!$mapComp.length) {
			// no map found, do nothing
			return null;
		}
		
		var map = new Map($mapComp[0], function (map) {
			var $displayedAddress = $("#displayedAddress");
			BingGeocodingProvider.bind($displayedAddress[0], "change", map, updateFormElements);
			var stores = getStoreData();
			
			if (!stores && $displayedAddress.attr("data-use-geolocation") == "true") {
				if (!currentPosition) {
					// TODO: make generic for all regions
					var initialView = $mapComp.data('country-code');
					if (!regionBoundingBoxes[initialView]) {
						BingGeocodingProvider.geocode($mapComp.data('initial-view'), function (result) {
							map.update(result.bbox);
						});
					} else {
						map.update(regionBoundingBoxes[initialView]);
					}
				}
			}

			if (stores) {
				addResultMarkers(stores, map);
				// center the map on the added markers
				// but only if there are more than one
				var points;
				if (stores.length > 1) {
					points = $.map(stores, function (store) { return store.geoPoint; });
				}
				if(stores.length == 1) {
					points = BingGeocodingProvider.getBoxAroundGeoPoint(stores[0].geoPoint);
				}
				map.update(BingGeocodingProvider.getBoundingBox(points));
			}
			updateMapWithGeolocation();
		});
		
		return map;
	};

	var updateMapWithGeolocation = function () {
		// if geolocation is available and requested attempt to fix the map on it
		if (currentPosition) {
			//this is really necessary??
			var pos = { latitude : currentPosition.latitude, longitude : currentPosition.longitude };
			var $displayedAddress = $("#displayedAddress");
			if (map) {
				map.layers[0].clearMarkers();
			}
			BingGeocodingProvider.reverseGeocode(pos,
				function(result) {
					$displayedAddress.val(result.name);
					$displayedAddress.trigger("change");
			}, null, $displayedAddress.data("language"));
		}
	};

	/**
	 * Returns an array of all the stores in the JSON object embedded in the page
	 * or only one store, if the optional id parameter is given.
	 *
	 * The function does not parse the JSON more than once and, if geolocation is
	 * performed at a later time, enhances the store objects with a bing maps directions
	 * URL that takes the detected location into account.
	 */
	var getStoreData = function (id) {
		if (!getStoreData.cache) {
			var itemsSource = $('#itemsSource').html();
			if (itemsSource) {
				var data = $.parseJSON(itemsSource);
				if (data && data.items) {
					getStoreData.cache = data.items;
					
					$.each(getStoreData.cache, function (idx, store) {
						if (!isMobileResultPage) {
							// add a static map URL string to the object
							store.mapImageUrl = BingGeocodingProvider.getMapImageUrl(getStoreLocation(store), {mapSize: "310,265"});
							// TODO: factor out strip tags into an utility function
							store.largerMapUrl = BingGeocodingProvider.getLargerMapUrl($("<div>" + store.address + "</div>").text());
						}
						store.directionsUrl = getDirectionsUrl(getStoreLocation(store), currentPosition, isMobileResultPage);
						//add initial index to members; zero indexed; used to restore 'best match' sort
						store.initialIndex = idx;
					});
				}
			}
		}

		// if the user was geolocated, update his all directionsUrls to reflect the source
		if (getStoreData.cache && !getStoreData.cache.geolocated && currentPosition) {
			getStoreData.cache.geolocated = true;
			$.each(getStoreData.cache, function (idx, store) {
				store.directionsUrl = getDirectionsUrl(getStoreLocation(store), currentPosition, isMobileResultPage);
			});
		}

		if (id) {
			var result = {};
			$.each(getStoreData.cache, function (idx, store) {
				if (store.id === id) {
					result = store;
					return false;
				}
			});
			return result;
		}

		return getStoreData.cache;
	};
	
	/**
	 * Comparator used to sort partners by Best Match
	 */
	var sortByBestMatch = function(a, b) {
		var va =  (a != null && a.initialIndex != null) ? a.initialIndex : 0,
			vb =  (b != null && b.initialIndex != null) ? b.initialIndex : 0;
		return (va - vb);
	};

	/**
	 * Comparator used to sort, case insensitive, strings
	 */
	var sortyByName = function(a, b) {
		//for our friends IE7,8 do not reuse arguments; zachleat.com/web/array-sort/
		var va =  (a != null && a.name != null) ? ("" + a.name.trim()).toLowerCase() : "",
			vb =  (b != null && b.name != null) ? ("" + b.name.trim()).toLowerCase() : "";
		return ((va < vb) ? -1 : ((va > vb) ? 1 : 0));
	};

	/**
	 * Returns either the store's coordinates encoded in an object -
	 * {lat, lon}, or the store's full address, as a string with stripped tags.
	 */
	var getStoreLocation = function (store) {
		var destination;
		if (store.geoPoint && store.geoPoint.latitude && store.geoPoint.longitude) {
			destination = {latitude: store.geoPoint.latitude, longitude: store.geoPoint.longitude };
		} else {
			// we also strip the tags out of the address
			destination = $("<div>" + store.address + "</div>").text();
			//for regions, check if country is present in the address
			var countryName = $("INPUT[name=cc]").val();
			if (isRegion() && destination.indexOf(countryName) < 0) {
				destination = destination + ", " + countryName;
			}
		}
		return destination;
	};
	
	/**
	 * @param cc the 'country code' to be checked; if emtpy the page html-lang attribute is used
	 * @return true if the current used 'country code' is in fact a region,  as defined by HP 
	 */
	var isRegion = function(cc) {
		if (!cc) {
			cc = $("html").attr("lang");
			cc = ( cc && cc.split('-')[1] ? cc.split('-')[1] : cc) ;
		}
		return !(regionBoundingBoxes[cc] === undefined);
	};

	var addResultMarkers = function (results, map, append) {
		if (!append) {
			// clear all the markers on the map
			map.layers[0].clearMarkers();
		}
		// if results is not iterable, don't try anything
		if (!results || !results.length) return;

		// create markers for all the results
		var markers = [];
		$.each(results, function (idx, result) {
			var geopoint = result.geoPoint;
			if (geopoint && geopoint.latitude && geopoint.longitude) {
				var infoboxConfig = { visible: false },
					tpl = new Template($("#mapInfoBoxTemplate").html(), "@");

				// add the bing directions URL to the result object
				result.directionsUrl = getDirectionsUrl(geopoint, currentPosition, isMobileResultPage);
				infoboxConfig.htmlContent = tpl.render(result).value;
				infoboxConfig.id = $(infoboxConfig.htmlContent).data('infobox-id');
				markers.push({
					//is this really necessary?!
					position: { latitude: geopoint.latitude, longitude: geopoint.longitude },
					infoboxConfig: infoboxConfig
				});
			}
		});
		map.layers[0].addMarkers(markers);
	};


	var updateResults = function (stores) {
		// we need to re-initialize the pagination
		// object with the new value for all the stores	
		var $pagination = $(".pagination"),
			$partnersList = $("#partnersList"),
			pagination = new Pagination($pagination[0], stores),
			paginationTpl = new Template($("#pagesNoTemplate").html(), "@"),
			itemsTpl = new Template($("#itemsListTemplate").html(), "@");
		
		stores = stores.slice(pagination.paginationData.fromIndex, pagination.paginationData.toIndex);
		$partnersList.html(itemsTpl.render({ items: stores }).value);
		$("#pagesNoTarget").html(paginationTpl.render({ pagination: formatPaginationData(pagination.paginationData) }).value);
		
		// initialize expanders for partner details on mobile pages after each update
		$partnersList.find("LI > UL.links.related > LI > A.collapsed[href]").each(function() {
			new Expander(this);
		});
	};

	// TODO: refactor pagination and move this there
	var formatPaginationData = function (paginationData) {
		var result = {};
		result.fromPagedIndex = paginationData.fromIndex + 1;
		result.elementsNo = paginationData.elementsNo;
		result.toIndex = (paginationData.elementsNo < paginationData.toIndex) ?
				paginationData.elementsNo : paginationData.toIndex;
		return result;
	};

	/**
	 * Returns only the items inside stores that have the
	 * name attribute the same as storeName;
	 */
	var filterStoresByName = function (stores, storeName) {
		var stores = getStoreData();
		return $.grep(stores, function (store) {
			return store.name === storeName;
		});
	};
	
	/** returns only the stores matching checked store names */
	var filterStores = function(stores) {
		var $checkedStores = $('INPUT[name="partnerName"]:checked');
		if ($checkedStores.length == 0 || $checkedStores.filter('INPUT[value="all"]').length > 0) {
			return stores;
		}
		var checkedStoreNames = [];
		$checkedStores.each(function(idx, el) {
			checkedStoreNames.push(el.value);
		})
		return $.grep(stores, function (store) {
			return $.inArray(store.name, checkedStoreNames) >= 0;
		});
	}

	/**
	 * Creates the store name filtering behavior in the
	 * SLS results page (the store name checkboxes).
	 */
	var initStoreNameFilter = function (map) {
		var $partnerName = $('INPUT[name="partnerName"]'),
			$partnerNamesLabel = $('#partnerNames').prev('A').find('SPAN.meta');

		$partnerName.on('change', function (e) {
			// get all checked filters
			var $checked = $partnerName.filter('INPUT:checked'),
				$allStores = $checked.filter("INPUT[value='all']"),
				stores = [], names = [], label;

			// all stores was pressed
			if ($(e.target).attr("value") === "all") {			    
				// if all stores are to be placed, clear every other checkbox
				if (e.target.checked) {
				    $(e.target).attr("ignore-event", "true");
					$partnerNamesLabel.html($allStores.siblings('LABEL').html());
					$checked.not("INPUT[value='all']").each(function(){
						this.checked=false;
						$(this).trigger("change");
					});
					$(e.target).attr("ignore-event", "false");
					stores = getStoreData();
				}
			} else if ($checked.length >=2 && $allStores.length && $allStores.attr("ignore-event") != "true") {
				$allStores.trigger('click');
				// uncheck all stores and start over 
				return;
			}

			// if all is not checked, update the view with the current selected stores
			if (!$allStores.length) {
				$checked.each(function (idx, el) {
					var name = $(el).val();
					stores = stores.concat(filterStoresByName(stores, name));
					names.push(name);
				});
				label = names.join(", ");
				if (label.length > 43) {
					label = label.substring(0, 40) + "...";
				}
				$partnerNamesLabel.html(label);
			}

			updateResults(stores);
			if (map) {
				addResultMarkers(stores, map);
			}
		});
	};

	/**
	 * Enables the infobox view when hovering over a table a row,
	 * in the list view of the sls results page;
	 */
	var initTableInfoBox = function () {
		var $table = $('#list table'),
			$infoBox = $("#tableInfoBox"),
			infoBoxTemplate,
			$navExpander = $('.navExpander'),
			$tableViewButton = $('#listTabButton');

		if (!$infoBox.length) return;

		var isListView = function () {
			return $tableViewButton.hasClass('expanded') || !$tableViewButton.length;
		}
		
		// if we have no tabs, the table view is default;
		// we initially hide the infobox because the sidebar is expanded
		if (isListView()) {
			HPUtils.hide($infoBox);
		}
		
		infoBoxTemplate = new Template($("#tableInfoBoxTemplate").html(), "@");

		// when hovering on a table row
		var updateInfoBox = function (e) {
			var row = this,
				storeData = getStoreData($(row).data("partner-id"));
			$("<img/>").error(function() {
					storeData.mapImageUrl = "";
					$infoBox.html(infoBoxTemplate.render(storeData).value);
				}).attr("src", storeData.mapImageUrl);
			$infoBox.html(infoBoxTemplate.render(storeData).value);
			$.each($table.find('tr'), function(idx, val) {
				$(val).removeClass('activeRow');
			});
			$(this).addClass("activeRow");
			//initially $infoBox is hidden
			HPUtils.show($infoBox);
		};

		$table.on('click', 'tbody tr', updateInfoBox);
		// re-add the handler every time the page is
		// changed because new rows are added
		$('.pagination').bind("pageadded", function (event) {
			$table.on('click', 'tbody tr', updateInfoBox);
		});
		$table.find('tbody tr:first-child').trigger('click');

		// when showing the table view, hide the nav sidebar
		$tableViewButton.on('click', function (e) {
			if ($navExpander.hasClass('expanded')) {
				$navExpander.trigger('click');
			}
		});

		// when toggling the nav sidebar, also toggle the infobox
		$navExpander.on('click', function (e) {
			if (isListView()) {
				if ($navExpander.hasClass('expanded')) {
					HPUtils.hide($infoBox);
				} else {
					setTimeout(function () {
						HPUtils.show($infoBox);
					}, 500);
				}
			}
		});
		if (isListView()) {
			$navExpander.trigger('click');
		}
	};
	
	var encodeBingGeocodingResource = function (resource) {
		var address = {}, coords = {};
		if (!resource) { 
			resource = {};
		} else {
			coords = resource.geocodePoints[0].coordinates;
			address = resource.address;
		}
		
		// remove the zip code if we get a street name
		if (address && address.addressLine) {
			address.postalCode = null;
		}
		
		// switch Panama; TODO: remove when the countries CSV is updated
		if (address.countryRegion === 'Panamá') {
			address.countryRegion = 'Panama';
		}
		
		return { 
			displayedAddress: resource.name,
			latitude: coords[0],
			longitude: coords[1],
			bbox: resource.bbox,
			street: address.addressLine,
			zipCode: address.postalCode,
			city: address.locality,
			province: address.adminDistrict,
			cc: address.countryRegion,
			valid: true
		}
	};
	
	/**
	 * Callback for geocoding and reverse geocoding (when the map is clicked or the displayed
	 * address is changed, to update the hidden form fields.
	 */
	var updateFormElements = function (result) {
		if (result) {
			result = encodeBingGeocodingResource(result);
			$.each(result, function (fieldName, fieldValue) {
				//these two changes have to go in in java code
				if (fieldName == 'latitude') {
					fieldName = 'lat';
				}
				if (fieldName == 'longitude') {
					fieldName = 'lon';
				}
				$('input[name=' + fieldName + ']').val(fieldValue ? fieldValue : "");
			});
			$("INPUT[name='valid']").change();
		}
		// always validate address because there might be no suggestion from Bing available
		validateAddress();
	};

	var validateAddress = function() {
		var $locationError = $("#locationError"),
			$wrongCountryError = $("#wrongCountryError"),
			$validation = $('INPUT[name=valid]');
			
		// validate only when location search is used
		if ($("#searchTypeLocalarea:checked").length > 0) {
			var $displayedAddress = $('#displayedAddress'),
			// jQuery converts "true" and "false" to Boolean when using .data
			// but Zepto keeps it as String, so always use .attr when values are true or false Strings
			proximityEnabled = $displayedAddress.attr("data-proximity-enabled") == "true",
			countryName = $displayedAddress.attr("data-country-name");
			
			if (!(proximityEnabled || $("INPUT[name=city]").val().length || $("INPUT[name=zipCode]").val().length)) { 
				// no city or zipcode available
				if ($displayedAddress.val().length > 0) {
					HPUtils.show($locationError);
				} else {
					// do not show error message if no value inserted
					HPUtils.hide($locationError);
				}
				HPUtils.hide($wrongCountryError);
				$validation.val("false").change();
				return;
			}
			if (!HPUtils.sameCountry($("INPUT[name=cc]").val(), countryName)) {
				// we're searching in a different country
				if ($displayedAddress.val().length > 0) {
					HPUtils.show($wrongCountryError);
				} else {
					HPUtils.hide($wrongCountryError);
				}
				HPUtils.hide($locationError);
				$validation.val("false").change();
				return;
			}
		}
		$validation.val("true").change();
		HPUtils.hide($locationError);
		HPUtils.hide($wrongCountryError);
	};
	
	
	AutoSuggest.Filters["currentcountryonly"] = function(index, suggestion) {
		var cTemplate = new Template("${" + "resourceSets[0].resources[" + index + "].address.countryRegion" + "}");
		var suggCountry = cTemplate.render(this.originalSuggestions).tokens[0];
		if (HPUtils.sameCountry(suggCountry, $(this.element).data("country-name"))) {
			var retval = true;
			$(this.$suggestionList).find("LI A").each(function (i, elem) {
				if ($(elem).text() == suggestion) {
					return retval = false;
				}
			});
			return retval;
		}
		return false;
	};
	
	/** check if a valid range value has been entered */
	var validateRange = function(e) {
		var $range = $("#localareaSearchFields #range.number"),
			$wrongRangeError =  $("#wrongRangeError"),
			$validation = $('INPUT[name=valid]'),
			isValid = true;
			
		if ($range.length > 0 && $("#useRange").is(':checked')) {
			if (!$range.val() || !$range.val().match(/^\d+$/)) {
				isValid = false;
			} else {
				var rangeValue = parseInt($range.val()),
					min = $range.attr("min"),
					max = $range.attr("max");
				if ((min && rangeValue < parseInt(min)) || (max && rangeValue > parseInt(max))) {
					isValid = false;
				}
			}
		}
		if (isValid) {
			$validation.val("true").change();
			HPUtils.hide($wrongRangeError);
		} else {
			HPUtils.show($wrongRangeError);
			$validation.val("false").change();
		}
	};
	
	var googleMapsEncodeForRoute = function (param) {
		if (param && param.latitude && param.longitude) {
			return param.latitude + "," + param.longitude;
		} else if (param) {
			return encodeURI(param);
		}
		return "";
	}
	
	var GOOGLE_MAPS_URL = "http://maps.google.com/?hl=" + HPUtils.getLocaleCode();
	var getGoogleDirectionsUrl = function (destination, source) {
		if (!source) {
			return GOOGLE_MAPS_URL + "&daddr=" + googleMapsEncodeForRoute(destination);
		} else {
			return GOOGLE_MAPS_URL + "&saddr=" + googleMapsEncodeForRoute(source) + 
				"&daddr=" + googleMapsEncodeForRoute(destination);
		}
	};
	
	var getDirectionsUrl = function(destination, source, isForMobile) {
		return (isForMobile) ? getGoogleDirectionsUrl(destination, source)
			: BingGeocodingProvider.getDirectionsUrl(destination, source); 
	};
	
	return StoreFinder;
});

define("jQueryCompat", ["jquery"], function ($) {
	
	// Override html() and text() to fix bug: http://bugs.jquery.com/ticket/10603
//	$.fn.___html___ = $.fn.html;
//	$.fn.html = function(value) {
//		if (this.length > 0) {
//			var elem = this[0] || {};
//			if (elem.text && elem.tagName == "SCRIPT") {
//				if (value === undefined) {
//					return elem.text;
//				} else {
//					elem.text = value;
//				}
//			} else {
//				return $.fn.___html___.apply(this, arguments);
//			}
//		}
//	};
//	
//	$.fn.___text___ = $.fn.text;
//	$.fn.text = function(value) {
//		return jQuery.access( this, function( value ) {
//			if (this.text && this.tagName == "SCRIPT") {
//				return value === undefined ?
//						this.text
//						: this.text = value;
//			} else {
//				return value === undefined ?
//						jQuery.text( this ) :
//						this.empty().append( ( this[0] && this[0].ownerDocument || document ).createTextNode( value ) );
//			}
//		}, null, value, arguments.length );
//	};
	
	// the compatibility functions are designed
	// explicitly for Zepto, if it's not loaded
	// do nothing
	if (typeof Zepto == 'undefined') return;
	
	if (!$.getScript) {
		$.getScript = function (url, successCallback, errorCallback) {
	        var script = document.createElement("script"),
	            $script = $(script);
	        script.src = url;

	        $("head").append(script);
	        // if the success callback is defined
	        if (successCallback) {
	        	$script.bind("load", successCallback);
	        } 
	        if (errorCallback) {
	        	$script.bind("error", errorCallback);
	        }
		};
	};
	
	if (!$.grep) {
		$.grep = function (array, callback, invert) {
		    array = (array instanceof Array) ? array : [].slice.call(array); // if needed
		    invert = !!invert; // ensure boolean
		    return array.filter(function(item, i){ return invert !== callback(item, i); });
		}
	}
	
	// overwriting the Zepto extend function
	// to make it support deep copying
	// TODO: pulled from the Zepto development branch - remove after upgrading to 1.0 stable
	function isObject(value) { return value instanceof Object }
	function isPlainObject(value) {
		return isObject(value) && value != window && value.__proto__ == Object.prototype
	}
	function extend(target, source, deep) {
		for (key in source)
			if (deep && isPlainObject(source[key])) {
				if (!isPlainObject(target[key])) target[key] = {}
				extend(target[key], source[key], deep)
			} else if (source[key] !== undefined) target[key] = source[key]
	}

	// Copy all but undefined properties from one or more
	// objects to the `target` object.
	$.extend = function(target){
		var deep, args = [].slice.call(arguments, 1)
		if (typeof target == 'boolean') {
			deep = target
			target = args.shift()
		}
		args.forEach(function(arg){ extend(target, arg, deep) })
		return target
	}
	
	if (!$.fn.scrollTop || !$.fn.scrollLeft) {
		var getScrollOffset = function () {
			// always returns the scroll for the window and not the element
			// TODO: remove once implemented in Zepto
			if (window.pageYOffset || window.pageYOffset === 0) {
				return { top: window.pageYOffset, left: window.pageXOffset};
			} else if (window.scrollY || window.scrollY === 0) {
				return { top: window.scrollY, left: window.scrollX};
			} else {
				if (((t = window.document.documentElement) || (t = window.document.body.parentNode)) 
						&& typeof t.scrollTop == 'number') {
					return { top: t.scrollTop, left: t.scrollLeft};
				} else {
					return { top: window.document.body.scrollTop, left: window.document.body.scrollLeft};
				}
			}
			return undefined;
		};
		
		$.fn.scrollTop = function() {
			var offset = getScrollOffset();
			return offset ? offset.top : offset;
		};
		
		$.fn.scrollLeft = function () {
			var offset = getScrollOffset();
			return offset ? offset.left : offset;
		}
		
	}

	var TRANSITION_END_EVENT_NAMES = {
			'Moz' : 'transitionend', 
			'Webkit' : 'webkitTransitionEnd', 
			'O' : 'oTransitionEnd', 
			'ms': 'MSTransitionEnd'};
	
	/**
	 * Returns the name of the transition end event for the current browser or null if the browser does not 
	 * support transitions..
	 */
	var getTransitionEndEventName = function() {
		var s = (document.body || document.documentElement).style;
		var p = 'transition';
		if(typeof s[p] == 'string') {
			return true;
		}
		
		// Tests for vendor specific prop
		p = p.charAt(0).toUpperCase() + p.substr(1);
		for(var browserPrefix in TRANSITION_END_EVENT_NAMES) {
			if(typeof s[browserPrefix + p] == 'string') {
				return TRANSITION_END_EVENT_NAMES[browserPrefix];
			}
		}
		return null;
	};
	
	var TRANSITION_END_EVENT_NAME = getTransitionEndEventName();
	$.transitionsEnabled = (TRANSITION_END_EVENT_NAME != null);
	
	$.___on___ = $.on;
	$.on = function (types, selector, data, fn) {
		if (types == "transitionend" || types == "transitionEnd") {
			types = TRANSITION_END_EVENT_NAME;
			if (types == null) {
				return;
			}
		}
		this.___on____(types, selector, data, fn);
	}
	
   	$.parseJSON = function(json) {
    	return JSON.parse(json);
    }

	// https://github.com/madrobby/zepto/pull/376/files
	// Patch that enables using data objects with event handlers
	// in zepto. Planned to be merged in the main zepto release soon, 
	// remove when that is done.
   	var handlers = {}, _zid = 1;
   	function normalizeArgs(arg1, arg2) {
   		return ($.isFunction(arg2)) ? {data: arg1, callback: arg2} : {callback: arg1};
    }
    function zid(element) {
    	return element._zid || (element._zid = _zid++);
    }
    function eachEvent(events, fn, iterator){
    	if ($.isObject(events)) $.each(events, iterator);
    	else events.split(/\s/).forEach(function(type){ iterator(type, fn) });
    }
    function parse(event) {
    	var parts = ('' + event).split('.');
    	return {e: parts[0], ns: parts.slice(1).sort().join(' ')};
    }
    function matcherFor(ns) {
    	return new RegExp('(?:^| )' + ns.replace(' ', ' .* ?') + '(?: |$)');
    }
    function findHandlers(element, event, fn, selector) {
    	event = parse(event);
    	if (event.ns) var matcher = matcherFor(event.ns);
    	return (handlers[zid(element)] || []).filter(function(handler) {
    		return handler
    				&& (!event.e  || handler.e == event.e)
    				&& (!event.ns || matcher.test(handler.ns))
    				&& (!fn       || handler.fn == fn)
    				&& (!selector || handler.sel == selector);
    	});
    }
    function add(element, events, bindData, fn, selector, getDelegate, capture){
    	capture = !!capture;
    	var id = zid(element), set = (handlers[id] || (handlers[id] = []));
    	eachEvent(events, fn, function(event, fn) {
    		var delegate = getDelegate && getDelegate(fn, event),
    				callback = delegate || fn;
    		var proxyfn = function (event) {
    			var handler = findHandlers(this, event.type, fn);
    			if (handler.length) event.data = handler[0].bindData;
    			var result = callback.apply(element, [event].concat(event.trigData));
    			if (result === false) event.preventDefault();
    			return result;
    		};
    		var handler = $.extend(parse(event), {fn: fn, bindData: bindData, proxy: proxyfn, sel: selector, del: delegate, i: set.length});
    		set.push(handler);
    		element.addEventListener(handler.e, proxyfn, capture);
    	});
    }
    function remove(element, events, fn, selector){
    	var id = zid(element);
    	eachEvent(events || '', fn, function(event, fn){
    		findHandlers(element, event, fn, selector).forEach(function(handler){
    			delete handlers[id][handler.i];
    			element.removeEventListener(handler.e, handler.proxy, false);
    		});
    	});
    }

    $.event = { add: add, remove: remove };

    $.fn.bind = function(event, arg2, arg3){
    	var args = normalizeArgs(arg2, arg3);
    	return this.each(function(){
    		add(this, event, args.data, args.callback);
    	});
    };
    $.fn.unbind = function(event, callback){
    	return this.each(function(){
    		remove(this, event, callback);
    	});
    };
    $.fn.on = function(event, arg2, arg3, arg4){
    	if (!arg2 || $.isFunction(arg2) || $.isObject(arg2))
    		return this.bind(event, arg2, arg3);
    	else
    		return this.delegate(arg2, event, arg3, arg4);
    };
    $.fn.off = function(event, selector, callback){
    	return selector === undefined || $.isFunction(selector) ?
    			this.unbind(event, selector) : this.undelegate(selector, event, callback);
    };

});

define("PageUtils", ["jquery", "NodeUtils", "Expander"], function ($, NodeUtils, Expander) {
	"use strict"

	return {
		loadOnlineCommunities : function () {
			if ($('#community-widget-content').length > 0) {
				var url = '/{locale}/system/include/lithium_v2_hpe.jsp'.replace('{locale}', $('#community-widget-content').attr('data-locale'));
				$.get(url, function(data) {
					$('#community-widget-content').html(data);
					$('A.js_discussions_trigger').each(function(index, el) {
						var invoker = el;
						var target = $(el).closest('LI').children('DIV.js_discussions_target')[0];
						var expander = new Expander(invoker, target);
						expander.collapse();
					});
				});
			}
		},

		fixMainMenu : function() {
			$.each($('DIV#header>UL.menu>LI>A'), function(index, href) {
				var title = $(href).html();
				if (title && !title.match(/<\s*br\s*\/?>/g) && title.indexOf('&') != -1) {
					$(href).html( $('<textarea/>').html(title).val().replace('&', '&<br/>'));
				}
			});
		}
	}
});

var config = {
	baseUrl: "/ie/en/m/scripts/src",
	paths: {
		jquery: "../lib/zepto"
	}
};
// if internet explorer, set the path for jQuery to a CDN url
if (/MSIE\s([\d]+)/.exec(navigator.userAgent)) {
	config.paths['jquery'] = '//code.jquery.com/jquery.min.js';
}

require.config(config);

function onDOMContentLoaded() {
	require(["Backward"], function(Backward) {
		Backward.all();
	});
	
	require(["NodeUtils", "HPUtils", "Fix", "Expander", "SelList", "CustomSelect", "CustomInputRadio", "AutoSuggest",
	         "Slideshow", "Slider","Pagination", "Products", "Brightcove", "SocialDrawer", 
	         "StoreFinder", "jQueryCompat", "jquery", "PageUtils"], 
	        function (NodeUtils, HPUtils, Fix, Expander, SelList, CustomSelect, CustomInputRadio, AutoSuggest, 
	        		 Slideshow, Slider,Pagination, Products, Brightcove, SocialDrawer, 
	        		 StoreFinder, jQueryCompat, $, PageUtils) {
        "use strict"
		HPUtils.initNavs();
		HPUtils.enableAutoSubmit();
		HPUtils.highlightNonEmptyFields();
		HPUtils.initFilterSwitches();
		NodeUtils.enableCopyOf(document.getElementById("senderName"));
		Expander.initAll();
		SelList.initAll();
		CustomSelect.initAll();
		CustomInputRadio.initAll();
		AutoSuggest.initAll();
		Slideshow.initAll();
		Slider.initAll();
		Products.init();
		Brightcove.init();
		// deactivated until we get a valid key
		//LivePersonStatus.init();
		HPUtils.initModule(StoreFinder);
		
		var paginations = Pagination.initAll();
		
		Fix.all();
		SocialDrawer.init();
		PageUtils.loadOnlineCommunities();
		
		// trigger reflow in IE; IE we love you!
		document.body.className = document.body.className;
	});
}

function onLoad() {
	try {
		// remove the loading progress indicator if any 
		var l = document.getElementById("loading");
		if (l != null) {
			l.parentNode.removeChild(l);
		}
	} catch (e) {
		if (window.console) console.log(e);
	}
}

$(document).ready(onDOMContentLoaded);
$(window).bind("load", onLoad);


(function (document, window) {
	// reads the metadata from the page and passes it along
	// to our server-side tracking module
	
	var metadata = document.getElementsByTagName('meta'), i, j,
		TRACKING_URL, DYNAMIC_TRACKING_URL, beacon, requestBeacon, 
		pageTitle, pageLanguage, query = '', addParam, encode = encodeURIComponent, 
		trackedMetadata, trackedParams, params = window.location.search.substring(1).split("&"), 
		pause, param, html, head, script;
	
	html = document.getElementsByTagName('html')[0];
	
	// only perform this logic if server-side analytics are requested
	if (html.getAttribute('data-analytics') !== 'optimized') {
		// include client-side analytics script
		head = html.getElementsByTagName('head')[0];
		script = document.createElement('script');
		script.src = (document.location.href.indexOf("/m/") >= 0 
				? "http://welcome.hp-ww.com/cma/ng/lib/mobile/metrics.js"
				: "http://welcome.hp-ww.com/cma/ng/lib/bootstrap/metrics.js");
		head.appendChild(script);
		return false;
	} else {
		TRACKING_URL = html.getAttribute('data-analytics-endpoint') || '/analytics.do';
		DYNAMIC_TRACKING_URL = '/track.do';
	}
		
	addParam = function (query, paramName, paramValue) {
		query += !query ? '?' : '&';
		query += encode(paramName) + "=" + encode(paramValue);
		return query;
	};
	
	pause = function (x) {
		var now = new Date();
		var stop = now.getTime() + (x || 500);
		while (now.getTime() < stop) var now = new Date();
	};
	
	// pass the page <title> as pageTitle
	pageTitle = document.getElementsByTagName('title');
	if (pageTitle) {
		query = addParam(query, 'pageTitle', pageTitle[0].innerHTML);
	}
	
	// pass the language as pageLanguage
	pageLanguage = html.getAttribute('lang');
	if (pageLanguage) {
		query = addParam(query, 'pageLanguage', pageLanguage);
	}
	
	// pass the referrer of the page
	if (document.referrer) {
		query = addParam(query, 'pageReferrer', document.referrer);
	}
	
	// pass all the tracked metadata to the script in the query string
	trackedMetadata = ['simple_title', 'target_country', 'language', 
	                   'web_section_id', 'product_number', 'segment', 'lifecycle', 
	                   'bu', 'business_unit', 'linkType'];
	for (i = metadata.length - 1; i >= 0; i--) {
		if (metadata[i].getAttribute('name')) {
			for (j = trackedMetadata.length - 1; j >= 0; j--) {
				if (metadata[i].getAttribute('name') === trackedMetadata[j]) {
					query = addParam(query, trackedMetadata[j], metadata[i].getAttribute('content'));
					break;
				}
			}
		}
	}
	
	// pass all required parameters from the query string to the analytics script
	trackedParams = ['jumpId', 'reportSuite'];
	for (i = 0; i < params.length; i++) {
		param = params[i].split("=");
		for (j = trackedParams.length - 1; j >=0; j--) {
			if (param[0] === trackedParams[j]) {
				query = addParam(query, trackedParams[j], param[1]);
			}
		}
	}
	
	requestBeacon = function (url) {
		var beacon = document.createElement('img');
		beacon.src = url;
		beacon.setAttribute('alt', 'tracking image');
		document.body.appendChild(beacon);
		return beacon;
	};
	
	// create beacon and append it at the bottom of the page
	beacon = requestBeacon(TRACKING_URL + query);
	
	var links = document.getElementsByTagName('A'), 
		req, attr, type, len, jlen;
	for (i = 0, len = links.length; i < len; i++) {
		// track in-page activity
		attr = links[i].getAttribute('data-track');
		if (attr === "") {
			attr = "click";
		}
		// defaults to "custom link"
		type = links[i].getAttribute('data-linkType') || "o"; 
		
		if (attr) {
			var events = attr.split(','), handler = function (e) {
				// get any additional parameters
				var query = "&linkType=lnk_" + type.charAt(0).toLowerCase() + "&linkURL=" + encode(e.target.href), 
					params = e.target.getAttribute('data-trackParams');
				if (params)  { 
					query = query + "&" + params;
				}
				requestBeacon(beacon.src + query);
				pause(300);
				// do not stop propagation, need to flow through this handler
			};
			for (j = 0, jlen = events.length; j < jlen; j++) {
				if (typeof(links[i].addEventListener) === "unknown" || !links[i].addEventListener) {
					links[i].attachEvent('on' + events[j], handler);
				} else if (links[i].attachEvent) {
					links[i].addEventListener(events[j], handler, true);
				}
			}
		}
	}
})(document, window);


/* UnCompressed - Reason: UNKNOWN REASON */

/*
Date: 3/26/2013 7:48:49 AM
Non-published images:
/webdav/17%20United%20States-English%20Web%20-%20Mobile/Building%20Blocks/System/00%20Shared/Content/CSS/i//connect.facebook.net/${language}_${country}/all.js#xfbml=1&appId=${fbApplicationId}
*/